<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Chase&#39;s Club">
<meta property="og:url" content="https://www.chaseshen.club/index.html">
<meta property="og:site_name" content="Chase&#39;s Club">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chase&#39;s Club">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.chaseshen.club/">





  <title>Chase's Club</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chase's Club</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.chaseshen.club/2018/12/09/Laradock中MySQL连接的坑/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chase Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chase's Club">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/09/Laradock中MySQL连接的坑/" itemprop="url">Laradock中MySQL连接的坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-09T09:43:21+00:00">
                2018-12-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近开始使用Laradock作为开发环境进行项目开发，按照教程将必备的软件都搭建好了，结果在项目中一直连接不上MySQL。网上查了好多资料后知道了问题原因：<br>Docker中每个容器都是相对独立的，所以PHP-FPM和MySQL容器也是独立开的。在项目的配置文件中数据库host配置项一般是127.0.0.1，但这样写的话项目是去访问的PHP-FPM容器，这个容器中自然没有MySQL所以访问不到。</p>
<p>解决方案：</p>
<ol>
<li><p>首先打开<code>docker-compose.yml</code>文件，检查PHP-FPM配置中<code>links</code>选项是否连接了MySQL，如果没有则在此项中添加MySQL的容器名称，我这里是<code>mysql</code>，注意大小写。重新构建容器。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`php-fpm:</span><br><span class="line">links:</span><br><span class="line">-mysql</span><br></pre></td></tr></table></figure>
<p> <code>2. 进入项目中，将数据库配置中的</code>host<code>改为</code>mysql`，这样就完成了项目连接MySQL的操作。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.chaseshen.club/2018/11/20/PHP基础回顾-PHP中十六个魔术方法详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chase Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chase's Club">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/20/PHP基础回顾-PHP中十六个魔术方法详解/" itemprop="url">[PHP基础回顾]PHP中十六个魔术方法详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-20T17:54:16+00:00">
                2018-11-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PHP中把以两个下划线开头的方法称为魔术方法（Magic Method），这些方法在PHP中有举足轻重的作用。<br>魔术方法包括：</p>
<ul>
<li>__construct()  类的构造函数</li>
<li>__destruct()  类的析构函数</li>
<li>__call()  在对象中调用一个不可访问的方法时调用</li>
<li>__callStatic()  在静态方式中调用一个不可访问的方法时调用</li>
<li>__get()  获得一个类的成员变量时调用</li>
<li>__set()  设置一个类的成员变量时调用</li>
<li>__isset()  当对不可访问的属性调用isset()或empty()时调用</li>
<li>__unset()  当对不可访问的属性调用unset()时调用</li>
<li>__sleep()  执行serialize()时，先会调用这个方法</li>
<li>__wakeup()  执行unserialize()时，先会调用这个方法</li>
<li>__toString()  类被当做字符串时的回应方法</li>
<li>__invoke()  调用函数的方式调用一个对象时的回应方法</li>
<li>__set_state()  调用var_export()导出类时，此静态方法会被调用</li>
<li>__clone()  当对象复制完成时调用</li>
<li>__autoload()  尝试加载未定义的类</li>
<li>__debugInfo()  打印所需调试信息</li>
</ul>
<h1 id="construct"><a href="#construct" class="headerlink" title="__construct()"></a>__construct()</h1><p>类的构造函数，是对象创建完成后第一个被对象调用的方法。在每个类中都有一个构造方法，如果没有显示地声明它，那么类中都会默认存在一个没有参数且内容为空的构造方法。</p>
<ul>
<li><p>构造方法的作用<br>通常构造方法被用来执行一些有用的初始化任务，如对成员属性在创建对象时赋予初始值。</p>
</li>
<li><p>构造方法的在类中的声明格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function __constrct([参数列表])&#123;</span><br><span class="line"></span><br><span class="line">    方法体 //通常用来对成员属性进行初始化赋值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在类中声明构造方法需要注意的事项</p>
</li>
</ul>
<ol>
<li>在同一个类中只能声明一个构造方法，原因是，PHP不支持构造函数重载。</li>
<li>构造方法名称是以两个下画线开始的__construct()</li>
</ol>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    class Person</span><br><span class="line">    &#123;                                                                      </span><br><span class="line">            public $name;        </span><br><span class="line">            public $age;        </span><br><span class="line">            public $sex;        </span><br><span class="line">                                                                 </span><br><span class="line">        /**</span><br><span class="line">         * 显示声明一个构造方法且带参数</span><br><span class="line">         */                                                                                       </span><br><span class="line">        public function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=22)</span><br><span class="line">        &#123;      </span><br><span class="line">            $this-&gt;name = $name;</span><br><span class="line">            $this-&gt;sex = $sex;</span><br><span class="line">            $this-&gt;age = $age;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        /**</span><br><span class="line">         * say 方法</span><br><span class="line">         */</span><br><span class="line">        public function say()</span><br><span class="line">        &#123; </span><br><span class="line">            echo &quot;我叫：&quot; . $this-&gt;name . &quot;，性别：&quot; . $this-&gt;sex . &quot;，年龄：&quot; . $this-&gt;age;</span><br><span class="line">        &#125;   </span><br><span class="line">                                                                                           </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>创建对象$Person1且不带任参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$Person1 = new Person();</span><br><span class="line">echo $Person1-&gt;say(); //输出:我叫：，性别：男，年龄：27</span><br></pre></td></tr></table></figure></p>
<p>创建对象$Person2且带参数“小明”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$Person2 = new Person(&quot;小明&quot;);</span><br><span class="line">echo $Person2-&gt;say(); //输出：我叫：小明，性别：男，年龄：22</span><br></pre></td></tr></table></figure></p>
<p>创建对象$Person3且带三个参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$Person3 = new Person(&quot;李四&quot;,&quot;男&quot;,25);</span><br><span class="line">echo $Person3-&gt;say(); //输出：我叫：李四，性别：男，年龄：25</span><br></pre></td></tr></table></figure></p>
<h1 id="destruct"><a href="#destruct" class="headerlink" title="__destruct()"></a>__destruct()</h1><p>类的析构函数，与构造方法对应的就是析构方法。<br>析构方法允许在销毁一个类之前执行的一些操作或完成一些功能，比如说关闭文件、释放结果集等。</p>
<p>析构方法是PHP5才引进的新内容。</p>
<p>析造方法的声明格式与构造方法 <strong>construct() 比较类似，也是以两个下划线开始的方法 </strong>destruct() ，这种析构方法名称也是固定的。</p>
<ul>
<li>析构方法的声明格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function __destruct()</span><br><span class="line">&#123;</span><br><span class="line"> //方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：析构函数不能带有任何参数。</p>
<ul>
<li>析构方法的作用<br>一般来说，析构方法在PHP中并不是很常用，它属类中可选择的一部分，通常用来完成一些在对象销毁前的清理任务。</li>
</ul>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person&#123;     </span><br><span class="line">                                                        </span><br><span class="line">    public $name;         </span><br><span class="line">    public $age;         </span><br><span class="line">    public $sex;         </span><br><span class="line">                                                                    </span><br><span class="line">    public function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=22)</span><br><span class="line">    &#123;   </span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;sex  = $sex;</span><br><span class="line">        $this-&gt;age  = $age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * say 说话方法</span><br><span class="line">     */</span><br><span class="line">    public function say()</span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;我叫：&quot;.$this-&gt;name.&quot;，性别：&quot;.$this-&gt;sex.&quot;，年龄：&quot;.$this-&gt;age;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 声明一个析构方法</span><br><span class="line">     */</span><br><span class="line">    public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">            echo &quot;我觉得我还可以再抢救一下，我的名字叫&quot;.$this-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$Person = new Person(&quot;小明&quot;);</span><br><span class="line">unset($Person); //销毁上面创建的对象$Person</span><br></pre></td></tr></table></figure></p>
<p>上面的程序运行时输出：<br><code>我觉得我还可以再抢救一下，我的名字叫小明</code></p>
<h1 id="call"><a href="#call" class="headerlink" title="__call()"></a>__call()</h1><p>在对象中调用一个不可访问方法时调用，该方法有两个参数，第一个参数<code>$function_name</code>会自动接收不存在的方法名，第二个<code>$arguments</code>则以数组的方式接收不存在方法的多个参数。</p>
<ul>
<li><p>__call() 方法的格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function __call(string $function_name, array $arguments)</span><br><span class="line">&#123;</span><br><span class="line">    // 方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>call() 方法的作用<br>为了避免当调用的方法不存在时产生错误，而意外的导致程序中止，可以使用 </strong>call() 方法来避免。</p>
</li>
</ul>
<p>该方法在调用的方法不存在时会自动调用，程序仍会继续执行下去。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;                             </span><br><span class="line">    function say()</span><br><span class="line">    &#123;  </span><br><span class="line">                              </span><br><span class="line">           echo &quot;Hello, world!&lt;br&gt;&quot;; </span><br><span class="line">    &#125;      </span><br><span class="line">        </span><br><span class="line">    /**</span><br><span class="line">     * 声明此方法用来处理调用对象中不存在的方法</span><br><span class="line">     */</span><br><span class="line">    function __call($funName, $arguments)</span><br><span class="line">    &#123; </span><br><span class="line">          echo &quot;你所调用的函数：&quot; . $funName . &quot;(参数：&quot; ;  // 输出调用不存在的方法名</span><br><span class="line">          print_r($arguments); // 输出调用不存在的方法时的参数列表</span><br><span class="line">          echo &quot;)不存在！&lt;br&gt;\n&quot;; // 结束换行                      </span><br><span class="line">    &#125;                                          </span><br><span class="line">&#125;</span><br><span class="line">$Person = new Person();            </span><br><span class="line">$Person-&gt;run(&quot;teacher&quot;); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法</span><br><span class="line">$Person-&gt;eat(&quot;小明&quot;, &quot;苹果&quot;);             </span><br><span class="line">$Person-&gt;say();</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">你所调用的函数：run(参数：Array ( [0] =&gt; teacher ) )不存在！</span><br><span class="line"></span><br><span class="line">你所调用的函数：eat(参数：Array ( [0] =&gt; 小明 [1] =&gt; 苹果 ) )不存在！</span><br><span class="line"></span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure></p>
<h1 id="callStatic"><a href="#callStatic" class="headerlink" title="__callStatic()"></a>__callStatic()</h1><p>用静态方式中调用一个不可访问方法时调用，此方法与上面所说的<code>__call()</code>功能除了<code>__callStatic()</code>是为静态方法准备的之外，其它都是一样的。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    function say()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        echo &quot;Hello, world!&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 声明此方法用来处理调用对象中不存在的方法</span><br><span class="line">     */</span><br><span class="line">    public static function __callStatic($funName, $arguments)</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;你所调用的静态方法：&quot; . $funName . &quot;(参数：&quot; ;  // 输出调用不存在的方法名</span><br><span class="line">        print_r($arguments); // 输出调用不存在的方法时的参数列表</span><br><span class="line">        echo &quot;)不存在！&lt;br&gt;\n&quot;; // 结束换行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$Person = new Person();</span><br><span class="line">$Person::run(&quot;teacher&quot;); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法</span><br><span class="line">$Person::eat(&quot;小明&quot;, &quot;苹果&quot;);</span><br><span class="line">$Person-&gt;say();</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你所调用的静态方法：run(参数：Array ( [0] =&gt; teacher ) )不存在！</span><br><span class="line">你所调用的静态方法：eat(参数：Array ( [0] =&gt; 小明 [1] =&gt; 苹果 ) )不存在！</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure></p>
<h1 id="get"><a href="#get" class="headerlink" title="__get()"></a>__get()</h1><p>获得一个类的成员变量时调用。在 php 面向对象编程中，类的成员属性被设定为<code>private</code>后，如果我们试图在外面调用它则会出现“不能访问某个私有属性”的错误。那么为了解决这个问题，我们可以使用魔术方法<code>__get()</code>。</p>
<ul>
<li>魔术方法__get()的作用<br>在程序运行过程中，通过它可以在对象的外部获取私有成员属性的值。</li>
</ul>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    private $name;</span><br><span class="line">    private $age;</span><br><span class="line"></span><br><span class="line">    function __construct($name=&quot;&quot;, $age=1)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age = $age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在类中添加__get()方法，在直接获取属性值时自动调用一次，以属性名作为参数传入并处理</span><br><span class="line">     * @param $propertyName</span><br><span class="line">     *</span><br><span class="line">     * @return int</span><br><span class="line">     */</span><br><span class="line">    public function __get($propertyName)</span><br><span class="line">    &#123;   </span><br><span class="line">        if ($propertyName == &quot;age&quot;) &#123;</span><br><span class="line">            if ($this-&gt;age &gt; 30) &#123;</span><br><span class="line">                return $this-&gt;age - 10;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return $this-&gt;$propertyName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return $this-&gt;$propertyName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$Person = new Person(&quot;小明&quot;, 60);   // 通过Person类实例化的对象，并通过构造方法为属性赋初值</span><br><span class="line">echo &quot;姓名：&quot; . $Person-&gt;name . &quot;&lt;br&gt;&quot;;   // 直接访问私有属性name，自动调用了__get()方法可以间接获取</span><br><span class="line">echo &quot;年龄：&quot; . $Person-&gt;age . &quot;&lt;br&gt;&quot;;    // 自动调用了__get()方法，根据对象本身的情况会返回不同的值</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">姓名：小明</span><br><span class="line">年龄：50</span><br></pre></td></tr></table></figure></p>
<h1 id="set"><a href="#set" class="headerlink" title="__set()"></a>__set()</h1><p>设置一个类的成员变量时调用。设置私有属性， 给一个未定义的属性赋值时，此方法会被触发，传递的参数是被设置的<code>属性名</code>和<code>值</code>。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    private $name;</span><br><span class="line">    private $age;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&quot;&quot;,  $age=25)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age  = $age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 声明魔术方法需要两个参数，真接为私有属性赋值时自动调用，并可以屏蔽一些非法赋值</span><br><span class="line">     * @param $property</span><br><span class="line">     * @param $value</span><br><span class="line">     */</span><br><span class="line">    public function __set($property, $value) &#123;</span><br><span class="line">        if ($property==&quot;age&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            if ($value &gt; 150 || $value &lt; 0) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        $this-&gt;$property = $value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在类中声明说话的方法，将所有的私有属性说出</span><br><span class="line">     */</span><br><span class="line">    public function say()&#123;</span><br><span class="line">        echo &quot;我叫&quot;.$this-&gt;name.&quot;，今年&quot;.$this-&gt;age.&quot;岁了&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$Person=new Person(&quot;小明&quot;, 25); //注意，初始值将被下面所改变</span><br><span class="line">//自动调用了__set()函数，将属性名name传给第一个参数，将属性值”小红”传给第二个参数</span><br><span class="line">$Person-&gt;name = &quot;小红&quot;;     //赋值成功。如果没有__set()，则出错。</span><br><span class="line">//自动调用了__set()函数，将属性名age传给第一个参数，将属性值16传给第二个参数</span><br><span class="line">$Person-&gt;age = 16; //赋值成功</span><br><span class="line">$Person-&gt;age = 160; //160是一个非法值，赋值失效</span><br><span class="line">$Person-&gt;say();  //输出：我叫小红，今年16岁了</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我叫小红，今年16岁了</span><br></pre></td></tr></table></figure></p>
<h1 id="isset"><a href="#isset" class="headerlink" title="__isset()"></a>__isset()</h1><p>当对不可访问属性调用<code>isset()</code>或<code>empty()</code>时调用。</p>
<p>在看这个方法之前我们看一下<code>isset()</code>函数的应用，<code>isset()</code>是测定变量是否设定用的函数，传入一个变量作为参数，如果传入的变量存在则传回<code>true</code>，否则传回<code>false</code>。<br>那么如果在一个对象外面使用<code>isset()</code>这个函数去测定对象里面的成员是否被设定可不可以用它呢？</p>
<p>分两种情况，如果对象里面成员是公有的，我们就可以使用这个函数来测定成员属性，如果是私有的成员属性，这个函数就不起作用了，原因就是因为私有的被封装了，在外部不可见。那么我们就不可以在对象的外部使用<code>isset()</code>函数来测定私有成员属性是否被设定了呢？当然是可以的，但不是一成不变。你只要在类里面加上一个<code>__isset()</code>方法就可以了，当在类外部使用<code>isset()</code>函数来测定对象里面的私有成员是否被设定时，就会自动调用类里面的<code>__isset()</code>方法了帮我们完成这样的操作。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public $sex;</span><br><span class="line">    private $name;</span><br><span class="line">    private $age;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age  = $age;</span><br><span class="line">        $this-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param $content</span><br><span class="line">     *</span><br><span class="line">     * @return bool</span><br><span class="line">     */</span><br><span class="line">    public function __isset($content) &#123;</span><br><span class="line">        echo &quot;当在类外部使用isset()函数测定私有成员&#123;$content&#125;时，自动调用&lt;br&gt;&quot;;</span><br><span class="line">        echo  isset($this-&gt;$content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = new Person(&quot;小明&quot;, 25); // 初始赋值</span><br><span class="line">echo isset($person-&gt;sex),&quot;&lt;br&gt;&quot;;</span><br><span class="line">echo isset($person-&gt;name),&quot;&lt;br&gt;&quot;;</span><br><span class="line">echo isset($person-&gt;age),&quot;&lt;br&gt;&quot;;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 // public 可以 isset()</span><br><span class="line">当在类外部使用isset()函数测定私有成员name时，自动调用 // __isset() 内 第一个echo</span><br><span class="line">1 // __isset() 内第二个echo</span><br><span class="line">当在类外部使用isset()函数测定私有成员age时，自动调用 // __isset() 内 第一个echo</span><br><span class="line">1 // __isset() 内第二个echo</span><br></pre></td></tr></table></figure></p>
<h1 id="unset"><a href="#unset" class="headerlink" title="__unset()"></a>__unset()</h1><p>当对不可访问属性调用<code>unset()</code>时被调用。</p>
<p>看这个方法之前呢，我们也先来看一下<code>unset()</code>函数，<code>unset()</code>这个函数的作用是删除指定的变量且传回<code>true</code>，参数为要删除的变量。</p>
<p>那么如果在一个对象外部去删除对象内部的成员属性用<code>unset()</code>函数可以吗？</p>
<p>这里自然也是分两种情况：</p>
<ol>
<li><p>如果一个对象里面的成员属性是公有的，就可以使用这个函数在对象外面删除对象的公有属性。</p>
</li>
<li><p>如果对象的成员属性是私有的，我使用这个函数就没有权限去删除。</p>
</li>
</ol>
<p>虽然有以上两种情况，但我想说的是同样如果你在一个对象里面加上<code>__unset()</code>这个方法，就可以在对象的外部去删除对象的私有成员属性了。在对象里面加上了<code>__unset()</code>这个方法之后，在对象外部使用<code>unset()</code>函数删除对象内部的私有成员属性时，对象会自动调用<code>__unset()</code>函数来帮我们删除对象内部的私有成员属性。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public $sex;</span><br><span class="line">    private $name;</span><br><span class="line">    private $age;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age  = $age;</span><br><span class="line">        $this-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param $content</span><br><span class="line">     *</span><br><span class="line">     * @return bool</span><br><span class="line">     */</span><br><span class="line">    public function __unset($content) &#123;</span><br><span class="line">        echo &quot;当在类外部使用unset()函数来删除私有成员时自动调用的&lt;br&gt;&quot;;</span><br><span class="line">        echo  isset($this-&gt;$content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = new Person(&quot;小明&quot;, 25); // 初始赋值</span><br><span class="line">unset($person-&gt;sex);</span><br><span class="line">unset($person-&gt;name);</span><br><span class="line">unset($person-&gt;age);</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当在类外部使用unset()函数来删除私有成员时自动调用的</span><br><span class="line">1当在类外部使用unset()函数来删除私有成员时自动调用的</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<h1 id="sleep"><a href="#sleep" class="headerlink" title="__sleep()"></a>__sleep()</h1><p>执行<code>serialize()</code>时，先会调用这个函数。<code>serialize()</code>函数会检查类中是否存在一个魔术方法<code>__sleep()</code>。如果存在，则该方法会优先被调用，然后才执行序列化操作。</p>
<p>此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。</p>
<p>如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。</p>
<p>注意：<br><code>__sleep()</code>不能返回父类的私有成员的名字。这样做会产生一个 E_NOTICE 级别的错误。可以用 Serializable 接口来替代。</p>
<p>作用：<br><code>__sleep()</code>方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public $sex;</span><br><span class="line">    public $name;</span><br><span class="line">    public $age;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age  = $age;</span><br><span class="line">        $this-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @return array</span><br><span class="line">     */</span><br><span class="line">    public function __sleep() &#123;</span><br><span class="line">        echo &quot;当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;&quot;;</span><br><span class="line">        $this-&gt;name = base64_encode($this-&gt;name);</span><br><span class="line">        return array(&apos;name&apos;, &apos;age&apos;); // 这里必须返回一个数值，里边的元素表示返回的属性名称</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</span><br><span class="line">echo serialize($person);</span><br><span class="line">echo &apos;&lt;br/&gt;&apos;;</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当在类外部使用serialize()时会调用这里的__sleep()方法</span><br><span class="line">O:6:&quot;Person&quot;:2:&#123;s:4:&quot;name&quot;;s:8:&quot;5bCP5piO&quot;;s:3:&quot;age&quot;;i:25;&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="wakeup"><a href="#wakeup" class="headerlink" title="__wakeup()"></a>__wakeup()</h1><p>执行unserialize()时，先会调用这个函数。<br>与之相反，<code>unserialize()</code>会检查是否存在一个<code>__wakeup()</code>方法。如果存在，则会先调用<code>__wakeup</code>方法，预先准备对象需要的资源。</p>
<p>作用：<br><code>__wakeup()</code>经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public $sex;</span><br><span class="line">    public $name;</span><br><span class="line">    public $age;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age  = $age;</span><br><span class="line">        $this-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @return array</span><br><span class="line">     */</span><br><span class="line">    public function __sleep() &#123;</span><br><span class="line">        echo &quot;当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;&quot;;</span><br><span class="line">        $this-&gt;name = base64_encode($this-&gt;name);</span><br><span class="line">        return array(&apos;name&apos;, &apos;age&apos;); // 这里必须返回一个数值，里边的元素表示返回的属性名称</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * __wakeup</span><br><span class="line">     */</span><br><span class="line">    public function __wakeup() &#123;</span><br><span class="line">        echo &quot;当在类外部使用unserialize()时会调用这里的__wakeup()方法&lt;br&gt;&quot;;</span><br><span class="line">        $this-&gt;name = 2;</span><br><span class="line">        $this-&gt;sex = &apos;男&apos;;</span><br><span class="line">        // 这里不需要返回数组</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</span><br><span class="line">var_dump(serialize($person));</span><br><span class="line">var_dump(unserialize(serialize($person)));</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当在类外部使用serialize()时会调用这里的__sleep()方法</span><br><span class="line">string(58) &quot;O:6:&quot;Person&quot;:2:&#123;s:4:&quot;name&quot;;s:8:&quot;5bCP5piO&quot;;s:3:&quot;age&quot;;i:25;&#125;&quot; 当在类外部使用serialize()时会调用这里的__sleep()方法</span><br><span class="line">当在类外部使用unserialize()时会调用这里的__wakeup()方法</span><br><span class="line">object(Person)#2 (3) &#123; [&quot;sex&quot;]=&gt; string(3) &quot;男&quot; [&quot;name&quot;]=&gt; int(2) [&quot;age&quot;]=&gt; int(25) &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString()"></a>__toString()</h1><p>类被当成字符串时的回应方法。<br>作用：<br><code>__toString()</code>方法用于一个类被当成字符串时应怎样回应。例如 <code>echo $obj;</code> 应该显示些什么。</p>
<p>注意：<br>此方法必须返回一个字符串，否则将发出一条 <code>E_RECOVERABLE_ERROR</code> 级别的致命错误。</p>
<p>警告：<br>不能在<code>__toString()</code>方法中抛出异常。这么做会导致致命错误。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public $sex;</span><br><span class="line">    public $name;</span><br><span class="line">    public $age;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age  = $age;</span><br><span class="line">        $this-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __toString()</span><br><span class="line">    &#123;</span><br><span class="line">        return  &apos;go go go&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</span><br><span class="line">echo $person;</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go go go</span><br></pre></td></tr></table></figure></p>
<p>那么如果类中没有 __toString() 这个魔术方法运行会发生什么呢？让我们来测试下：</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public $sex;</span><br><span class="line">    public $name;</span><br><span class="line">    public $age;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age  = $age;</span><br><span class="line">        $this-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</span><br><span class="line">echo $person;</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Catchable fatal error: Object of class Person could not be converted to string in D:\phpStudy\WWW\test\index.php on line 18</span><br></pre></td></tr></table></figure></p>
<p>页面报了一个致命错误，这是语法所不允许的。</p>
<h1 id="invoke"><a href="#invoke" class="headerlink" title="__invoke()"></a>__invoke()</h1><p>调用函数的方式调用一个对象时的回应方法。</p>
<p>作用：<br>当尝试以调用函数的方式调用一个对象时，<code>__invoke()</code>方法会被自动调用。</p>
<p>注意：<br>本特性只在 PHP 5.3.0 及以上版本有效。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public $sex;</span><br><span class="line">    public $name;</span><br><span class="line">    public $age;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age  = $age;</span><br><span class="line">        $this-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __invoke() &#123;</span><br><span class="line">        echo &apos;这可是一个对象哦&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</span><br><span class="line">$person();</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这可是一个对象哦</span><br></pre></td></tr></table></figure></p>
<p>如果执意要将对象当函数方法使用，那么会得到下面结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fatal error: Function name must be a string in D:\phpStudy\WWW\test\index.php on line 18</span><br></pre></td></tr></table></figure></p>
<h1 id="set-state"><a href="#set-state" class="headerlink" title="__set_state()"></a>__set_state()</h1><p>调用var_export()导出类时，此静态方法会被调用。</p>
<p>作用：<br>自 PHP 5.1.0 起，当调用<code>var_export()</code>导出类时，此静态方法会被自动调用。</p>
<p>参数：<br>本方法的唯一参数是一个数组，其中包含按<code>array(&#39;property&#39; =&gt; value, ...)</code>格式排列的类属性。</p>
<p>下面在没有加 __set_state() 情况按下，代码及运行结果如何：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public $sex;</span><br><span class="line">    public $name;</span><br><span class="line">    public $age;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age  = $age;</span><br><span class="line">        $this-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</span><br><span class="line">var_export($person);</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person::__set_state(array( &apos;sex&apos; =&gt; &apos;男&apos;, &apos;name&apos; =&gt; &apos;小明&apos;, &apos;age&apos; =&gt; 25, ))</span><br></pre></td></tr></table></figure></p>
<p>对象中的属性都打印出来了。</p>
<p>加了<code>__set_state()</code>之后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public $sex;</span><br><span class="line">    public $name;</span><br><span class="line">    public $age;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age  = $age;</span><br><span class="line">        $this-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static function __set_state($an_array)</span><br><span class="line">    &#123;</span><br><span class="line">        $a = new Person();</span><br><span class="line">        $a-&gt;name = $an_array[&apos;name&apos;];</span><br><span class="line">        return $a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</span><br><span class="line">$person-&gt;name = &apos;小红&apos;;</span><br><span class="line">var_export($person);</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person::__set_state(array( &apos;sex&apos; =&gt; &apos;男&apos;, &apos;name&apos; =&gt; &apos;小红&apos;, &apos;age&apos; =&gt; 25, ))</span><br></pre></td></tr></table></figure></p>
<h1 id="clone"><a href="#clone" class="headerlink" title="__clone()"></a>__clone()</h1><p>当对象复制完成时调用。<br>在多数情况下，我们并不需要完全复制一个对象来获得其中属性。但有一个情况下确实需要：如果你有一个 GTK 窗口对象，该对象持有窗口相关的资源。你可能会想复制一个新的窗口，保持所有属性与原来的窗口相同，但必须是一个新的对象（因为如果不是新的对象，那么一个窗口中的改变就会影响到另一个窗口）。还有一种情况：如果对象 A 中保存着对象 B 的引用，当你复制对象 A 时，你想其中使用的对象不再是对象 B 而是 B 的一个副本，那么你必须得到对象 A 的一个副本。</p>
<p>作用：<br>对象复制可以通过<code>clone</code>关键字来完成（如果可能，这将调用对象的<code>__clone()</code>方法）。对象中的<code>__clone()</code>方法不能被直接调用。</p>
<p>语法：<br><code>$copy_of_object = clone $object;</code></p>
<p>注意：<br>当对象被复制后，PHP 5 会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性 仍然会是一个指向原来的变量的引用。</p>
<p>当复制完成时，如果定义了<code>__clone()</code>方法，则新创建的对象（复制生成的对象）中的<code>__clone()</code>方法会被调用，可用于修改属性的值（如果有必要的话）。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public $sex;</span><br><span class="line">    public $name;</span><br><span class="line">    public $age;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age  = $age;</span><br><span class="line">        $this-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __clone()</span><br><span class="line">    &#123;</span><br><span class="line">        echo __METHOD__.&quot;你正在克隆对象&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</span><br><span class="line">$person2 = clone $person;</span><br><span class="line"></span><br><span class="line">var_dump(&apos;persion1:&apos;);</span><br><span class="line">var_dump($person);</span><br><span class="line">echo &apos;&lt;br&gt;&apos;;</span><br><span class="line">var_dump(&apos;persion2:&apos;);</span><br><span class="line">var_dump($person2);</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person::__clone你正在克隆对象</span><br><span class="line">string(9) &quot;persion1:&quot; object(Person)#1 (3) &#123; [&quot;sex&quot;]=&gt; string(3) &quot;男&quot; [&quot;name&quot;]=&gt; string(6) &quot;小明&quot; [&quot;age&quot;]=&gt; int(25) &#125; </span><br><span class="line">string(9) &quot;persion2:&quot; object(Person)#2 (3) &#123; [&quot;sex&quot;]=&gt; string(3) &quot;男&quot; [&quot;name&quot;]=&gt; string(6) &quot;小明&quot; [&quot;age&quot;]=&gt; int(25) &#125;</span><br></pre></td></tr></table></figure></p>
<p>克隆成功。</p>
<h1 id="autoload"><a href="#autoload" class="headerlink" title="__autoload()"></a>__autoload()</h1><p>尝试加载未定义的类。</p>
<p>作用：<br>你可以通过定义这个函数来启用类的自动加载。</p>
<p>在魔术函数<code>__autoload()</code>方法出现以前，如果你要在一个程序文件中实例化100个对象，那么你必须用<code>include</code>或者<code>require</code>包含进来100个类文件，或者你把这100个类定义在同一个类文件中 —— 相信这个文件一定会非常大，然后你就痛苦了。</p>
<p>但是有了<code>__autoload()</code>方法，以后就不必为此大伤脑筋了，这个类会在你实例化对象之前自动加载制定的文件。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 文件non_autoload.php </span><br><span class="line"> */ </span><br><span class="line">   </span><br><span class="line">require_once(&apos;project/class/A.php&apos;);  </span><br><span class="line">require_once(&apos;project/class/B.php&apos;);  </span><br><span class="line">require_once(&apos;project/class/C.php&apos;);  </span><br><span class="line">   </span><br><span class="line">if (条件A) &#123;  </span><br><span class="line">    $a = new A();  </span><br><span class="line">    $b = new B();  </span><br><span class="line">    $c = new C();  </span><br><span class="line">    // … 业务逻辑  </span><br><span class="line">&#125; else if (条件B) &#123;  </span><br><span class="line">    $a = newA();  </span><br><span class="line">    $b = new B();  </span><br><span class="line">    // … 业务逻辑  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到了吗？不用100个，只是3个看起来就有点烦了。而且这样就会有一个问题：如果脚本执行“条件B”这个分支时，C.php这个文件其实没有必要包含。因为，任何一个被包含的文件，无论是否使用，均会被php引擎编译。如果不使用，却被编译，这样可以被视作一种资源浪费。更进一步，如果C.php包含了D.php，D.php包含了E.php。并且大部分情况都执行“条件B”分支，那么就会浪费一部分资源去编译C.php,D.php,E.php三个“无用”的文件。</p>
<p>那么如果使用<code>__autoload()</code>方式呢？</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 文件autoload_demo.php </span><br><span class="line"> */ </span><br><span class="line">function  __autoload($className) &#123;  </span><br><span class="line">    $filePath = “project/class/&#123;$className&#125;.php”;  </span><br><span class="line">    if (is_readable($filePath)) &#123;  </span><br><span class="line">        require($filePath);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line">if (条件A) &#123;  </span><br><span class="line">    $a = new A();  </span><br><span class="line">    $b = new B();  </span><br><span class="line">    $c = new C();  </span><br><span class="line">    // … 业务逻辑  </span><br><span class="line">&#125; else if (条件B) &#123;  </span><br><span class="line">    $a = newA();  </span><br><span class="line">    $b = new B();  </span><br><span class="line">    // … 业务逻辑  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ok,不论效率怎么用，最起码界面看起来舒服多了，没有太多冗余的代。</p>
<p>当php引擎第一次使用类A，但是找不到时，会自动调用<code>__autoload()</code>方法，并将类名“A”作为参数传入。所以，我们在<code>__autoload()</code>中需要的做的就是根据类名，找到相应的文件，并包含进来，如果我们的方法也找不到，那么php引擎就会报错了。</p>
<p>注意：<br>这里可以只用<code>require</code>，因为一旦包含进来后，php引擎再遇到类A时，将不会调用<code>__autoload()</code>，而是直接使用内存中的类A，不会导致多次包含。</p>
<p>扩展：<br>其实php发展到今天，已经有将 <code>spl_autoload_register</code> — 注册给定的函数作为<code>__autoload()</code>的实现了，但是这个不在啊本文讲解之内，有兴趣可以自行看手册。</p>
<h1 id="debugInfo"><a href="#debugInfo" class="headerlink" title="__debugInfo()"></a>__debugInfo()</h1><p>打印所需调试信息。</p>
<p>注意：<br>该方法在PHP 5.6.0及其以上版本才可以用，如果你发现使用无效或者报错，请查看啊你的版本。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class C &#123;</span><br><span class="line">    private $prop;</span><br><span class="line"></span><br><span class="line">    public function __construct($val) &#123;</span><br><span class="line">        $this-&gt;prop = $val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @return array</span><br><span class="line">     */</span><br><span class="line">    public function __debugInfo() &#123;</span><br><span class="line">        return [</span><br><span class="line">            &apos;propSquared&apos; =&gt; $this-&gt;prop ** 2,</span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump(new C(42));</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object(C)#1 (1) &#123; [&quot;propSquared&quot;]=&gt; int(1764) &#125;</span><br></pre></td></tr></table></figure></p>
<p>再次注意：<br>这里的 <code>**</code> 是乘方的意思，也是在PHP5.6.0及其以上才可以使用，详情请查看PHP手册</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.chaseshen.club/2018/11/20/PHP基础回顾-可变变量和引用操作符/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chase Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chase's Club">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/20/PHP基础回顾-可变变量和引用操作符/" itemprop="url">[PHP基础回顾]可变变量和引用操作符</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-20T17:26:43+00:00">
                2018-11-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我发现自己在开发中很容易将可变变量操作符<code>$$</code>和引用操作符<code>&amp;</code>搞混，所以特开此贴加以区分牢记。</p>
<h1 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h1><p>可变变量允许我们动态地改变一个变量的名称。这个特性的工作原理是用一个变量的值作为另一个变量的名称。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$a = &apos;b&apos;;</span><br><span class="line">$$a = 5;</span><br><span class="line"></span><br><span class="line">echo $b; //输出：5</span><br><span class="line"></span><br><span class="line">//相当于：</span><br><span class="line">$b = 5;</span><br></pre></td></tr></table></figure></p>
<h1 id="引用操作符"><a href="#引用操作符" class="headerlink" title="引用操作符"></a>引用操作符</h1><p>引用操作符<code>&amp;</code>可以在关联赋值中使用。通常在将一个变量的值赋给另一个变量的时候，先产生原变量的一个副本，然后再将它保存在内存的其他地方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$a = 5;</span><br><span class="line">$b = $a;</span><br><span class="line">$a = 7;</span><br><span class="line"></span><br><span class="line">echo $b; //输出：5</span><br></pre></td></tr></table></figure></p>
<p>以上代码，首先产生<code>$a</code>的一个副本，然后再将它保存在<code>$b</code>中。如果随后改变<code>$a</code>的值，<code>$b</code>的值将不会改变。</p>
<p>可以使用引用操作符<code>&amp;</code>来避免产生这样的副本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$a = 5;</span><br><span class="line">$b = &amp;$a;</span><br><span class="line">$a = 7;</span><br><span class="line"></span><br><span class="line">echo $b; //输出：7</span><br></pre></td></tr></table></figure></p>
<p>引用就像一个别名，而不是一个指针。<code>$a</code>和<code>$b</code>都指向了内存的相同地址。<br>可以通过重置它们来改变所指向的地址：<br><code>unset($a)</code>，重置<code>$a</code>并不会改变<code>$b</code>的值，但是可以破坏<code>$a</code>和值<code>7</code>保存在内存中的链接。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.chaseshen.club/2018/11/19/PHP基础回顾-while循环和do-while循环/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chase Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chase's Club">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/19/PHP基础回顾-while循环和do-while循环/" itemprop="url">[PHP基础回顾]while循环和do...while循环</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-19T22:36:23+00:00">
                2018-11-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>用PHP开发了这么多年，遇到需要使用循环的时候好像一般很少选择while循环或者do…while循环，时间久了感觉对它们有点不那么熟了，最近刚好在巩固PHP基础知识，于是单独拿出来复习一下。</p>
<h1 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h1><p>PHP中最简单的循环就是while循环。就像if语句，它也依赖于一个条件。<br>while循环语句和if循环语句的不同在于，if语句只有在条件为true的情况下才执行后续的代码<strong>一次</strong>，而while循环语句只要其条件为true，就会不断地<strong>重复</strong>执行代码块。<br>通常，当我们不知道所需的重复次数时，可以使用while循环语句。如果要求一个固定次数的重复，可以考虑使用for循环语句。</p>
<p>while循环的基本结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$num = 1;</span><br><span class="line">while ($num &lt;= 5) &#123;</span><br><span class="line">	echo $num.&apos;&lt;br /&gt;&apos;;</span><br><span class="line">	$num++;</span><br><span class="line">&#125;</span><br><span class="line">//1</span><br><span class="line">//2</span><br><span class="line">//3</span><br><span class="line">//4</span><br><span class="line">//5</span><br></pre></td></tr></table></figure></p>
<h1 id="do…while循环"><a href="#do…while循环" class="headerlink" title="do…while循环"></a>do…while循环</h1><p>do…while循环与while循环不同，因为它的测试条件在整个语句块的最后，这就意味着do…while循环中的语句或语句块至少会执行一次。即使这个条件一开始就是false，do…while循环中的这个代码块还是会执行一次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$num = 100;</span><br><span class="line">do &#123;</span><br><span class="line">	echo $num.&apos;&lt;br /&gt;&apos;;</span><br><span class="line">&#125; while ($num &lt; 1);</span><br><span class="line">//100</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.chaseshen.club/2018/11/17/华硕RT-AC86U刷梅林改版系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chase Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chase's Club">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/17/华硕RT-AC86U刷梅林改版系统/" itemprop="url">华硕RT-AC86U刷梅林改版系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-17T22:53:37+00:00">
                2018-11-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="刷机前的准备"><a href="#刷机前的准备" class="headerlink" title="刷机前的准备"></a>刷机前的准备</h1><ul>
<li>EXT格式的1G以上U盘一个，如果不知道怎么格式化，可以查看此文章附录。（可选）</li>
<li>改版梅林安装包，<a href="https://1drv.ms/u/s!ArS0nJ_RMzVYgtwvUNgsl7Q1Z9W75Q" target="_blank" rel="noopener">下载地址</a>，或直接到<a href="http://koolshare.cn/thread-127878-1-1.html" target="_blank" rel="noopener">Coolshare论坛下载</a></li>
<li>科学上网工具离线安装包，<a href="https://1drv.ms/u/s!ArS0nJ_RMzVYgtwuoBmaqxYUM2UrxA" target="_blank" rel="noopener">下载地址</a>，或直接到<a href="https://github.com/hq450/fancyss" target="_blank" rel="noopener">GitHub</a>上找到与你机器相匹配的</li>
</ul>
<h1 id="正式开刷"><a href="#正式开刷" class="headerlink" title="正式开刷"></a>正式开刷</h1><h2 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h2><ol>
<li>拿到机器后，打开机器背后开关键，然后连上电源，开机。</li>
<li>找到一根网线，一头接自己的电脑，另一头接路由器的LAN口，或者直接连接路由器的Wi-Fi信号。</li>
<li>在浏览器地址栏中输入<a href="http://router.asus.com/" target="_blank" rel="noopener">router.asus.com</a>进入管理后台。</li>
<li>依次设置自己的PPPoE、无线WIFI、管理后台账号，设置完之后会进入到官方原版的后台界面。</li>
</ol>
<h2 id="刷改版梅林固件"><a href="#刷改版梅林固件" class="headerlink" title="刷改版梅林固件"></a>刷改版梅林固件</h2><ol>
<li>在后台管理界面中找到<code>高级设置</code>-<code>系统管理</code>-<code>固件升级</code>，选择刚才将已准备好的梅林固件（格式为.w），然后点击上传，等待两三分钟即可，当重启后重新进入后台时有一个<code>Powered by Asuswrt-Merlin &amp; Coolshare</code>代表成功。</li>
<li>双清路由器。进入<code>高级设置</code>-<code>系统设置</code>，找到<code>Presistent JFFS2 parttition</code>，将<code>Format JFFS partition at next boot</code>和<code>Enable JFFS custom scripts and configs</code>两项都设置为是，并点击应用本页面设置按钮，然后重启路由器即可。</li>
</ol>
<h2 id="安装科学上网工具"><a href="#安装科学上网工具" class="headerlink" title="安装科学上网工具"></a>安装科学上网工具</h2><ol>
<li>由于梅林已经取消软件中心的科学上网工具在线安装，所以可采取离线安装的方式。</li>
<li>从<a href="https://1drv.ms/u/s!ArS0nJ_RMzVYgtwuoBmaqxYUM2UrxA" target="_blank" rel="noopener">这里</a>上下载离线安装包，打开软件中心，先点击更新将软件中心升级到最新版本，然后点击离线安装，上传刚才下载的安装包，注意格式需要为.tar.gz，如果不对，手动将其补全后再上传。</li>
<li>等待安装成功后，再打开科学上网，再配置自己的节点即可。</li>
</ol>
<h2 id="挂载虚拟内存（可选）"><a href="#挂载虚拟内存（可选）" class="headerlink" title="挂载虚拟内存（可选）"></a>挂载虚拟内存（可选）</h2><ol>
<li>将已准备好的EXT格式U盘插入路由器背部接口（2.0或3.0都可以）</li>
<li>打开软件中心，将<code>虚拟内存</code>这个软件安装上</li>
<li>打开该软件，选择这个磁盘，我这里叫做<code>sda</code>，选择虚拟内存大小为512M或1G，然后点创建虚拟内存，等待一段时间即可。</li>
<li>再次打开<code>软件中心</code>-<code>虚拟内存</code>，确保状态显示为在<code>/mnt/sda</code>下找到<code>swapfile</code>，且已成功挂载！，表明已挂载成功。</li>
</ol>
<h1 id="附录：U盘格式化为EXT格式"><a href="#附录：U盘格式化为EXT格式" class="headerlink" title="附录：U盘格式化为EXT格式"></a>附录：U盘格式化为EXT格式</h1><p>准备好一个1G以上的U盘（随便的都行，利用率不高），并格式化为EXT2,3,4任意的格式，我这边用的是EXT3。</p>
<h2 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h2><ol>
<li>如果没有Linux基础，可使用软件进行操作，可参考百度经验：<a href="https://jingyan.baidu.com/article/fea4511a142846f7bb912522.html" target="_blank" rel="noopener">如何在windows下把硬盘格式化成EXT3格式？</a></li>
<li>如果有一定Linux基础，可使用SSH连接到路由器通过路由器进行操作，具体步骤如下：</li>
</ol>
<ul>
<li>打开路由器后台<code>高级设置</code>-<code>系统设置</code>，找到<code>服务</code>中的启用<code>SSH</code>，选择打开<code>LAN+WAN</code>，然后保存设置。</li>
<li>下载一个叫PuTTY的软件，hostname填<code>192.168.50.1</code>（路由器后台地址，可能不一样，自己查看下） 然后选择<code>SSH</code>。port端口号为<code>22</code>，然后点open。</li>
<li>用自己前面设置的路由器账号密码登录即可，然后出现命令行界面。</li>
<li>在U盘插入路由器后面的情况下，依次输入以下命令（两横杠后的是解释说明，不用输入），然后等待显示完成即可。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df -h // 找到你的盘符,如：sda1</span><br><span class="line">umount /dev/sda1 // 解除进程的占用</span><br><span class="line">/bin/mkntfs /dev/sda1 // 格式化硬盘为ntfs格式</span><br><span class="line">mkfs.ext4 -T largefile /dev/sda1 // 格式化硬盘为ext4格式</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="macOS系统"><a href="#macOS系统" class="headerlink" title="macOS系统"></a>macOS系统</h2><ol>
<li>确保已经安装了Mac下的包管理软件Homebrew，如果没有，可以用以下命令安装<br><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></li>
<li>安装 e2fsprogs<br><code>brew install e2fsprogs</code></li>
<li>插上U盘，执行以下命令在执行结果中找到U盘盘符，我这里是<code>/dev/disk2s1</code><br><code>diskutil list</code></li>
<li><p>卸载U盘并将其格式化为<code>ext2/3/4</code>格式，这里以<code>ext3</code>为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">diskutil unmountdisk /dev/disk2s1</span><br><span class="line">sudo $(brew --prefix e2fsprogs)/sbin/mkfs.ext3 /dev/disk2s1</span><br></pre></td></tr></table></figure>
</li>
<li><p>中间可能会有确认提示，按提示操作即可。格式化完成就能直接拔掉U盘了。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.chaseshen.club/2018/11/05/Redis中的数据结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chase Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chase's Club">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/05/Redis中的数据结构/" itemprop="url">Redis中的数据结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-05T22:58:27+00:00">
                2018-11-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis有5个基本数据结构，<em>string</em>、<em>list</em>、<em>hash</em>、<em>set</em>和<em>zset</em>。它们是日常开发中使用频率非常高应用最为广泛的数据结构，把这5个数据结构都吃透了，基本就掌握了Redis应用知识的一半了。</p>
<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><p>string表示的是一个可变的字节数组，我们初始化字符串的内容、可以拿到字符串的长度，可以获取string的子串，可以覆盖string的子串内容，可以追加子串。<br><img src="/images/redis/string.png" alt><br>Redis的字符串是动态字符串，是可以修改的字符串，采用预分配冗余空间的方式来减少内存的频繁分配，如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p>
<h3 id="初始化字符串"><a href="#初始化字符串" class="headerlink" title="初始化字符串"></a>初始化字符串</h3><p><code>set 变量名称 变量的内容</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; set abc 123</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p>
<h3 id="获取字符串的内容"><a href="#获取字符串的内容" class="headerlink" title="获取字符串的内容"></a>获取字符串的内容</h3><p><code>get 变量名称</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; get abc</span><br><span class="line">&quot;123&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="获取字符串的长度"><a href="#获取字符串的长度" class="headerlink" title="获取字符串的长度"></a>获取字符串的长度</h3><p><code>strlen 变量名称</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; strlen abc</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></p>
<h3 id="获取子串"><a href="#获取子串" class="headerlink" title="获取子串"></a>获取子串</h3><p><code>getrange 变量名称 开始位置 结束位置</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; getrange abc 1 2</span><br><span class="line">&quot;23&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="覆盖子串"><a href="#覆盖子串" class="headerlink" title="覆盖子串"></a>覆盖子串</h3><p><code>setrange 变量名称 开始位置 目标子串</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; setrange abc 1 543</span><br><span class="line">(integer) 4  #返回覆盖完成后新生成的字符串的长度</span><br><span class="line">&gt; get abc</span><br><span class="line">&quot;1543&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="追加子串"><a href="#追加子串" class="headerlink" title="追加子串"></a>追加子串</h3><p><code>append 变量名称 追加字符串</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; append abc 123</span><br><span class="line">(integer) 7  #返回追加完成后新生成的字符串的长度</span><br><span class="line">&gt; get abc</span><br><span class="line">&quot;1543123&quot;</span><br></pre></td></tr></table></figure></p>
<p>注：字符串没有提供字串插入方法和子串删除方法。</p>
<h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; set abc 42</span><br><span class="line">OK</span><br><span class="line">&gt; get abc</span><br><span class="line">&quot;42&quot;</span><br><span class="line">&gt; incrby abc 100</span><br><span class="line">(integer) 142</span><br><span class="line">&gt; get abc</span><br><span class="line">&quot;142&quot;</span><br><span class="line">&gt; decrby abc 100</span><br><span class="line">(integer) 42</span><br><span class="line">&gt; get abc</span><br><span class="line">&quot;42&quot;</span><br><span class="line">&gt; incr abc  # 等价于incrby abc 1</span><br><span class="line">(integer) 43</span><br><span class="line">&gt; decr abc  # 等价于decrby abc 1</span><br><span class="line">(integer) 42</span><br></pre></td></tr></table></figure>
<p>计数器是有范围的，它不能超过Long.Max，不能低于Long.MIN</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; set abc 9223372036854775807</span><br><span class="line">OK</span><br><span class="line">&gt; incr abc</span><br><span class="line">(error) ERR increment or decrement would overflow</span><br><span class="line">&gt; set abc -9223372036854775808</span><br><span class="line">OK</span><br><span class="line">&gt; decr abc</span><br><span class="line">(error) ERR increment or decrement would overflow</span><br></pre></td></tr></table></figure>
<h3 id="过期和删除"><a href="#过期和删除" class="headerlink" title="过期和删除"></a>过期和删除</h3><p>字符串可以使用del指令进行主动删除，可以使用expire指令设置过期时间，到点会自动删除，这属于被动删除。可以使用ttl指令获取字符串的寿命。单位为秒。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; expire abc 60</span><br><span class="line">(integer) 1  # 1表示设置成功，0表示变量abc不存在</span><br><span class="line">&gt; ttl abc</span><br><span class="line">(integer) 50  # 还有50秒的寿命，返回-2表示变量不存在，-1表示没有设置过期时间</span><br><span class="line">&gt; del abc</span><br><span class="line">(integer) 1  # 删除成功返回1</span><br><span class="line">&gt; get abc</span><br><span class="line">(nil)  # 变量abc没有了</span><br></pre></td></tr></table></figure></p>
<h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><p><img src="/images/redis/list.png" alt><br>Redis将列表数据结构命名为list而不是array，是因为列表的存储结构用的是链表而不是数组，而且链表还是双向链表。因为它是链表，所以随机定位性能较弱，首尾插入删除性能较优。如果list的列表长度很长，使用时我们一定要关注链表相关操作的时间复杂度。</p>
<h3 id="负下标"><a href="#负下标" class="headerlink" title="负下标"></a>负下标</h3><p>链表元素的位置使用自然数<code>0,1,2,....n-1</code>表示，还可以使用负数<code>-1,-2,...-n</code>来表示，<code>-1</code>表示「倒数第一」，<code>-2</code>表示「倒数第二」，那么<code>-n</code>就表示第一个元素，对应的下标为<code>0</code>。</p>
<h3 id="队列／堆栈"><a href="#队列／堆栈" class="headerlink" title="队列／堆栈"></a>队列／堆栈</h3><p>链表可以从表头和表尾追加和移除元素，结合使用<code>rpush/rpop/lpush/lpop</code>四条指令，可以将链表作为队列或堆栈使用，左向右向进行都可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 右进左出</span><br><span class="line">&gt; rpush chase go</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; rpush chase java python</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; lpop chase</span><br><span class="line">&quot;go&quot;</span><br><span class="line">&gt; lpop chase</span><br><span class="line">&quot;java&quot;</span><br><span class="line">&gt; lpop chase</span><br><span class="line">&quot;python&quot;</span><br><span class="line"># 左进右出</span><br><span class="line">&gt; lpush chase go java python</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; rpop chase</span><br><span class="line">&quot;go&quot;</span><br><span class="line">...</span><br><span class="line"># 右进右出</span><br><span class="line">&gt; rpush chase go java python</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; rpop chase </span><br><span class="line">&quot;python&quot;</span><br><span class="line">...</span><br><span class="line"># 左进左出</span><br><span class="line">&gt; lpush chase go java python</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; lpop chase</span><br><span class="line">&quot;python&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>在日常应用中，列表常用来作为异步队列来使用。</p>
<h3 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h3><p>使用llen指令获取链表长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush chase go java python</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; llen chase</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></p>
<h3 id="随机读"><a href="#随机读" class="headerlink" title="随机读"></a>随机读</h3><p>可以使用<code>lindex</code>指令访问指定位置的元素，使用<code>lrange</code>指令来获取链表子元素列表，提供<code>start</code>和<code>end</code>下标参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush chase go java python</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; lindex chase 1</span><br><span class="line">&quot;java&quot;</span><br><span class="line">&gt; lrange chase 0 2</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;python&quot;</span><br><span class="line">&gt; lrange chase 0 -1  # -1表示倒数第一</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;python&quot;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>lrange</code>获取全部元素时，需要提供<code>end_index</code>，如果没有负下标，就需要首先通过<code>llen</code>指令获取长度，才可以得出<code>end_index</code>的值，有了负下标，使用<code>-1</code>代替<code>end_index</code>就可以达到相同的效果。</p>
<h3 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h3><p>使用lset指令在指定位置修改元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush chase go java python</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; lset chase 1 javascript</span><br><span class="line">OK</span><br><span class="line">&gt; lrange chase 0 -1</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;javascript&quot;</span><br><span class="line">3) &quot;python&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>使用<code>linsert</code>指令在列表的中间位置插入元素，有经验的程序员都知道在插入元素时，我们经常搞不清楚是在指定位置的前面插入还是后面插入，所以antirez在linsert指令里增加了方向参数before/after来显示指示前置和后置插入。不过让人意想不到的是<code>linsert</code>指令并不是通过指定位置来插入，而是通过指定具体的值。这是因为在分布式环境下，列表的元素总是频繁变动的，意味着上一时刻计算的元素下标在下一时刻可能就不是你所期望的下标了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush chase go java python</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; linsert chase before java ruby</span><br><span class="line">(integer) 4</span><br><span class="line">&gt; lrange chase 0 -1</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;ruby&quot;</span><br><span class="line">3) &quot;java&quot;</span><br><span class="line">4) &quot;python&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>列表的删除操作也不是通过指定下标来确定元素的，你需要指定删除的最大个数以及元素的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush chase go java python</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; lrem chase 1 java</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; lrange chase 0 -1</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;python&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="定长列表"><a href="#定长列表" class="headerlink" title="定长列表"></a>定长列表</h3><p>在实际应用场景中，我们有时候会遇到「定长列表」的需求。比如要以走马灯的形式实时显示中奖用户名列表，因为中奖用户实在太多，能显示的数量一般不超过100条，那么这里就会使用到定长列表。维持定长列表的指令是<code>ltrim</code>，需要提供两个参数<code>start</code>和<code>end</code>，表示需要保留列表的下标范围，范围之外的所有元素都将被移除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush chase go java python javascript ruby erlang rust cpp</span><br><span class="line">(integer) 8</span><br><span class="line">&gt; ltrim chase -3 -1</span><br><span class="line">OK</span><br><span class="line">&gt; lrange chase 0 -1</span><br><span class="line">1) &quot;erlang&quot;</span><br><span class="line">2) &quot;rust&quot;</span><br><span class="line">3) &quot;cpp&quot;</span><br></pre></td></tr></table></figure></p>
<p>如果指定参数的<code>end</code>对应的真实下标小于<code>start</code>，其效果等价于<code>del</code>指令，因为这样的参数表示需要需要保留列表元素的下标范围为空。</p>
<h3 id="快速列表"><a href="#快速列表" class="headerlink" title="快速列表"></a>快速列表</h3><p><img src="/images/redis/quicklist.png" alt><br>如果再深入一点，你会发现Redis底层存储的还不是一个简单的linkedlist，而是称之为快速链表quicklist的一个结构。首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。所以Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>
<h1 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h1><p><img src="/images/redis/hash.png" alt><br>哈希等价于Java语言的HashMap或者是Python语言的dict，在实现结构上它使用二维结构，第一维是数组，第二维是链表，hash的内容key和value存放在链表中，数组里存放的是链表的头指针。通过key查找元素时，先计算key的hashcode，然后用hashcode对数组的长度进行取模定位到链表的表头，再对链表进行遍历获取到相应的value值，链表的作用就是用来将产生了「hash碰撞」的元素串起来。Java语言开发者会感到非常熟悉，因为这样的结构和HashMap是没有区别的。哈希的第一维数组的长度也是2^n。</p>
<p><img src="/images/redis/hash1.png" alt></p>
<h3 id="增加元素"><a href="#增加元素" class="headerlink" title="增加元素"></a>增加元素</h3><p>可以使用hset一次增加一个键值对，也可以使用hmset一次增加多个键值对<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; hmset ireader go fast java fast python slow</span><br><span class="line">OK</span><br><span class="line">&gt; hget ireader go</span><br><span class="line">&quot;fast&quot;</span><br><span class="line">&gt; hmget ireader go python</span><br><span class="line">1) &quot;fast&quot;</span><br><span class="line">2) &quot;slow&quot;</span><br><span class="line">&gt; hgetall ireader</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;fast&quot;</span><br><span class="line">3) &quot;java&quot;</span><br><span class="line">4) &quot;fast&quot;</span><br><span class="line">5) &quot;python&quot;</span><br><span class="line">6) &quot;slow&quot;</span><br><span class="line">&gt; hkeys ireader</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;python&quot;</span><br><span class="line">&gt; hvals ireader</span><br><span class="line">1) &quot;fast&quot;</span><br><span class="line">2) &quot;fast&quot;</span><br><span class="line">3) &quot;slow&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h3><p>可以使用<code>hdel</code>删除指定key，<code>hdel</code>支持同时删除多个key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; hmset ireader go fast java fast python slow</span><br><span class="line">OK</span><br><span class="line">&gt; hdel ireader go</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hdel ireader java python</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></p>
<h3 id="判断元素是否存在"><a href="#判断元素是否存在" class="headerlink" title="判断元素是否存在"></a>判断元素是否存在</h3><p>通常我们使用<code>hget</code>获得key对应的value是否为空就直到对应的元素是否存在了，不过如果value的字符串长度特别大，通过这种方式来判断元素存在与否就略显浪费，这时可以使用<code>hexists</code>指令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; hmset ireader go fast java fast python slow</span><br><span class="line">OK</span><br><span class="line">&gt; hexists ireader go</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></p>
<h3 id="计数器-1"><a href="#计数器-1" class="headerlink" title="计数器"></a>计数器</h3><p>hash结构还可以当成计数器来使用，对于内部的每一个key都可以作为独立的计数器。如果value值不是整数，调用<code>hincrby</code>指令会出错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; hincrby ireader go 1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hincrby ireader python 4</span><br><span class="line">(integer) 4</span><br><span class="line">&gt; hincrby ireader java 4</span><br><span class="line">(integer) 4</span><br><span class="line">&gt; hgetall ireader</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;python&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;java&quot;</span><br><span class="line">6) &quot;4&quot;</span><br><span class="line">&gt; hset ireader rust good</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hincrby ireader rust 1</span><br><span class="line">(error) ERR hash value is not an integer</span><br></pre></td></tr></table></figure></p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>当hash内部的元素比较拥挤时(hash碰撞比较频繁)，就需要进行扩容。扩容需要申请新的两倍大小的数组，然后将所有的键值对重新分配到新的数组下标对应的链表中(rehash)。如果hash结构很大，比如有上百万个键值对，那么一次完整rehash的过程就会耗时很长。这对于单线程的Redis里来说有点压力山大。所以Redis采用了渐进式rehash的方案。它会同时保留两个新旧hash结构，在后续的定时任务以及hash结构的读写指令中将旧结构的元素逐渐迁移到新的结构中。这样就可以避免因扩容导致的线程卡顿现象。</p>
<h3 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h3><p>Redis的hash结构不但有扩容还有缩容，从这一点出发，它要比Java的HashMap要厉害一些，Java的HashMap只有扩容。缩容的原理和扩容是一致的，只不过新的数组大小要比旧数组小一倍。</p>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>Java程序员都知道HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p>
<h3 id="增加元素-1"><a href="#增加元素-1" class="headerlink" title="增加元素"></a>增加元素</h3><p>可以一次增加多个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd ireader go java python</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></p>
<h3 id="读取元素"><a href="#读取元素" class="headerlink" title="读取元素"></a>读取元素</h3><p>使用<code>smembers</code>列出所有元素，使用<code>scard</code>获取集合长度，使用<code>srandmember</code>获取随机count个元素，如果不提供count参数，默认为1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd ireader go java python</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; smembers ireader</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;python&quot;</span><br><span class="line">3) &quot;go&quot;</span><br><span class="line">&gt; scard ireader</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; srandmember ireader</span><br><span class="line">&quot;java&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="删除元素-2"><a href="#删除元素-2" class="headerlink" title="删除元素"></a>删除元素</h3><p>使用<code>srem</code>删除一到多个元素，使用<code>spop</code>删除随机一个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd chase go java python rust erlang</span><br><span class="line">(integer) 5</span><br><span class="line">&gt; srem chase go java</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; spop chase</span><br><span class="line">&quot;erlang&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="判断元素是否存在-1"><a href="#判断元素是否存在-1" class="headerlink" title="判断元素是否存在"></a>判断元素是否存在</h3><p>使用<code>sismember</code>指令，只能接收单个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd chase go java python rust erlang</span><br><span class="line">(integer) 5</span><br><span class="line">&gt; sismember chase rust</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sismember chase javascript</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></p>
<h1 id="sortedset"><a href="#sortedset" class="headerlink" title="sortedset"></a>sortedset</h1><p><img src="/images/redis/sortedset.png" alt><br><code>SortedSet</code>(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p>
<p><code>zset</code>底层实现使用了两个数据结构，第一个是hash，第二个是跳跃列表，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。跳跃列表的目的在于给元素value排序，根据score的范围获取元素列表。</p>
<h3 id="增加元素-2"><a href="#增加元素-2" class="headerlink" title="增加元素"></a>增加元素</h3><p>通过<code>zadd</code>指令可以增加一到多个value/score对，score放在前面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd ireader 4.0 python</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd ireader 4.0 java 1.0 go</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></p>
<h3 id="长度-1"><a href="#长度-1" class="headerlink" title="长度"></a>长度</h3><p>通过指令<code>zcard</code>可以得到<code>zset</code>的元素个数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; zcard ireader</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></p>
<h3 id="删除元素-3"><a href="#删除元素-3" class="headerlink" title="删除元素"></a>删除元素</h3><p>通过指令<code>zrem</code>可以删除<code>zset</code>中的元素，可以一次删除多个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; zrem ireader go python</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></p>
<h3 id="计数器-2"><a href="#计数器-2" class="headerlink" title="计数器"></a>计数器</h3><p>同hash结构一样，<code>zset</code>也可以作为计数器使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd ireader 4.0 python 4.0 java 1.0 go</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; zincrby ireader 1.0 python</span><br><span class="line">&quot;5&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="获取排名和分数"><a href="#获取排名和分数" class="headerlink" title="获取排名和分数"></a>获取排名和分数</h3><p>通过<code>zscore</code>指令获取指定元素的权重，通过<code>zrank</code>指令获取指定元素的正向排名，通过<code>zrevrank</code>指令获取指定元素的反向排名[倒数第一名]。正向是由小到大，负向是由大到小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; zscore ireader python</span><br><span class="line">&quot;5&quot;</span><br><span class="line">&gt; zrank ireader go  # 分数低的排名考前，rank值小</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; zrank ireader java</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrank ireader python</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; zrevrank ireader python</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></p>
<h3 id="根据排名范围获取元素列表"><a href="#根据排名范围获取元素列表" class="headerlink" title="根据排名范围获取元素列表"></a>根据排名范围获取元素列表</h3><p>通过<code>zrange</code>指令指定排名范围参数获取对应的元素列表，携带<code>withscores</code>参数可以一并获取元素的权重。通过<code>zrevrange</code>指令按负向排名获取元素列表[倒数]。正向是由小到大，负向是由大到小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; zrange ireader 0 -1  # 获取所有元素</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;python&quot;</span><br><span class="line">&gt; zrange ireader 0 -1 withscores</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;java&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;python&quot;</span><br><span class="line">6) &quot;5&quot;</span><br><span class="line">&gt; zrevrange ireader 0 -1 withscores</span><br><span class="line">1) &quot;python&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;java&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;go&quot;</span><br><span class="line">6) &quot;1&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="根据score范围获取列表"><a href="#根据score范围获取列表" class="headerlink" title="根据score范围获取列表"></a>根据score范围获取列表</h3><p>通过<code>zrangebyscore</code>指令指定score范围获取对应的元素列表。通过<code>zrevrangebyscore</code>指令获取倒排元素列表。正向是由小到大，负向是由大到小。参数-inf表示负无穷，+inf表示正无穷。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; zrangebyscore ireader 0 5</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;python&quot;</span><br><span class="line">&gt; zrangebyscore ireader -inf +inf withscores</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;java&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;python&quot;</span><br><span class="line">6) &quot;5&quot;</span><br><span class="line">&gt; zrevrangebyscore ireader +inf -inf withscores  # 注意正负反过来了</span><br><span class="line">1) &quot;python&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;java&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;go&quot;</span><br><span class="line">6) &quot;1&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="根据范围移除元素列表"><a href="#根据范围移除元素列表" class="headerlink" title="根据范围移除元素列表"></a>根据范围移除元素列表</h3><p>可以通过排名范围，也可以通过score范围来一次性移除多个元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; zremrangebyrank ireader 0 1</span><br><span class="line">(integer) 2  # 删掉了2个元素</span><br><span class="line">&gt; zadd ireader 4.0 java 1.0 go</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; zremrangebyscore ireader -inf 4</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; zrange ireader 0 -1</span><br><span class="line">1) &quot;python&quot;</span><br></pre></td></tr></table></figure>
<h3 id="跳跃列表"><a href="#跳跃列表" class="headerlink" title="跳跃列表"></a>跳跃列表</h3><p><code>zset</code>内部的排序功能是通过「跳跃列表」数据结构来实现的，它的结构非常特殊，也比较复杂。这一块的内容深度读者要有心理准备。</p>
<p>因为<code>zset</code>要支持随机的插入和删除，所以它不好使用数组来表示。我们先看一个普通的链表结构。</p>
<p><img src="/images/redis/zset.png" alt></p>
<p>我们需要这个链表按照score值进行排序。这意味着当有新元素需要插入时，需要定位到特定位置的插入点，这样才可以继续保证链表是有序的。通常我们会通过二分查找来找到插入点，但是二分查找的对象必须是数组，只有数组才可以支持快速位置定位，链表做不到，那该怎么办？</p>
<p>想想一个创业公司，刚开始只有几个人，团队成员之间人人平等，都是联合创始人。随着公司的成长，人数渐渐变多，团队沟通成本随之增加。这时候就会引入组长制，对团队进行划分。每个团队会有一个组长。开会的时候分团队进行，多个组长之间还会有自己的会议安排。公司规模进一步扩展，需要再增加一个层级——部门，每个部门会从组长列表中推选出一个代表来作为部长。部长们之间还会有自己的高层会议安排。<br>跳跃列表就是类似于这种层级制，最下面一层所有的元素都会串起来。然后每隔几个元素挑选出一个代表来，再将这几个代表使用另外一级指针串起来。然后在这些代表里再挑出二级代表，再串起来。最终就形成了金字塔结构。<br>想想你老家在世界地图中的位置：亚洲–&gt;中国-&gt;安徽省-&gt;安庆市-&gt;枞阳县-&gt;汤沟镇-&gt;田间村-&gt;xxxx号，也是这样一个类似的结构。</p>
<p><img src="/images/redis/zset1.png" alt></p>
<p>「跳跃列表」之所以「跳跃」，是因为内部的元素可能「身兼数职」，比如上图中间的这个元素，同时处于L0、L1和L2层，可以快速在不同层次之间进行「跳跃」。<br>定位插入点时，先在顶层进行定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插进去。你也许会问那新插入的元素如何才有机会「身兼数职」呢？<br>跳跃列表采取一个随机策略来决定新元素可以兼职到第几层，首先L0层肯定是100%了，L1层只有50%的概率，L2层只有25%的概率，L3层只有12.5%的概率，一直随机到最顶层L31层。绝大多数元素都过不了几层，只有极少数元素可以深入到顶层。列表中的元素越多，能够深入的层次就越深，能进入到顶层的概率就会越大。<br>这还挺公平的，能不能进入中央不是靠拼爹，而是看运气。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.chaseshen.club/2018/10/25/PHP开发中需要区别的几组概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chase Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chase's Club">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/25/PHP开发中需要区别的几组概念/" itemprop="url">PHP开发中需要区别的几组概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-25T14:06:37+00:00">
                2018-10-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PHP/" itemprop="url" rel="index">
                    <span itemprop="name">PHP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-cookie和session区别"><a href="#1-cookie和session区别" class="headerlink" title="1. cookie和session区别"></a>1. cookie和session区别</h1><ul>
<li>session存在服务器，cookie存在浏览器；</li>
<li>session安全性比cookie高；</li>
<li>session为会话服务，在使用时需要开启服务，cookie不需要开启，可以直接使用。</li>
</ul>
<h1 id="2-redis和memcached区别"><a href="#2-redis和memcached区别" class="headerlink" title="2. redis和memcached区别"></a>2. redis和memcached区别</h1><ul>
<li>redis 系统库有个快照，即突然断电，数据还会存在，而memached 就没了；</li>
<li>memcached 是简单的键值对，Key-Value, redis 支持的存储方式很多，应用场景很多</li>
<li>redis 性能比memached 要高</li>
</ul>
<h1 id="3-myisam和innodb区别"><a href="#3-myisam和innodb区别" class="headerlink" title="3. myisam和innodb区别"></a>3. myisam和innodb区别</h1><ul>
<li>MyISAM 是非事务的存储引擎；适合用于频繁查询的应用；表锁，不会出现死锁；适合小数据，小并发。</li>
<li>innodb是支持事务的存储引擎；合于插入和更新操作比较多的应用；设计合理的话是行锁（最大区别就在锁的级别上）；适合大数据，大并发。</li>
</ul>
<h1 id="4-require和include区别"><a href="#4-require和include区别" class="headerlink" title="4. require和include区别"></a>4. require和include区别</h1><ul>
<li>报错的时候，include报严重警告，还是会继续执行后面程序；</li>
<li>require报致命错误，不会继续执行。</li>
<li>require_once 和 include_once 可以避免重复包含同一文件。</li>
</ul>
<h1 id="5-char和varchar的区别"><a href="#5-char和varchar的区别" class="headerlink" title="5. char和varchar的区别"></a>5. char和varchar的区别</h1><ul>
<li>char是一种固定长度的类型，varchar则是一种可变长度的类型，在检索操作中那些填补出来的空格字符将被去掉；</li>
<li>char(M)类型的数据列里，每个值都占用M个字节，如果某个长度小于M，MySQL就会在它的右边用空格字符补足；</li>
<li>在varchar(M)类型的数据列里，每个值只占用刚好够用的字节再加上一个用来记录其长度的字节（即总长度为L+1字节）。</li>
</ul>
<h1 id="6-print，echo，print-r区别"><a href="#6-print，echo，print-r区别" class="headerlink" title="6. print，echo，print_r区别"></a>6. print，echo，print_r区别</h1><ul>
<li>echo和print都可输出；</li>
<li>echo不是函数，没有返回值，而print是一个函数，有返回值；</li>
<li>如果只是输出，echo会更快；</li>
<li>print_r通常用于打印变量相关的信息，一般在调试的时候用；</li>
<li>print是打印字符串；</li>
<li>prin_r打印复合类型，数组或者对象。</li>
</ul>
<h1 id="7-构造函数和析构函数"><a href="#7-构造函数和析构函数" class="headerlink" title="7. 构造函数和析构函数"></a>7. 构造函数和析构函数</h1><ul>
<li>构造函数（方法）是对象创建完成后第一个被对象自动调用的方法；</li>
<li>它存在于每个声明的类中，是一个特殊的成员方法；</li>
<li>作用是执行一些初始化的任务；</li>
<li><p>PHP中使用__construct()声明构造方法，并且只能声明一个。</p>
</li>
<li><p>析构函数（方法）作用和构造方法正好相反，是对象被销毁之前最后一个被对象自动调用的方法；</p>
</li>
<li>是PHP5中新添加的内容作用是用于实现在销毁一个对象之前执行一些特定的操作，诸如关闭文件和释放内存等。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.chaseshen.club/2018/10/15/U盘如何格式化为ext3，ext4格式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chase Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chase's Club">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/15/U盘如何格式化为ext3，ext4格式/" itemprop="url">U盘如何格式化为ext3，ext4格式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-15T13:51:53+00:00">
                2018-10-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以 Mac 电脑下操作为例<br>插上U盘</p>
<ol>
<li><p>打开 Mac 终端，输入下面代码<br><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code><br>按回车键后要求你按任意键执行<br>输入 Mac 电脑密码，回车，会自动下载安装，过程需要稍等片刻。</p>
</li>
<li><p>输入下面代码-安装e2fsprogs<br><code>brew install e2fsprogs</code></p>
</li>
<li><p>输入下面代码-找到盘符<br><code>diskutil list</code></p>
</li>
<li><p>输入下面代码，在执行结果中找到 U盘盘符，我这里是 /dev/disk3，此时U盘会消失。<br><code>diskutil unmountdisk /dev/disk3</code></p>
</li>
<li><p>输入下面代码（4代表ext4格式，也可以是3即ext3格式，后面的disk3是盘符）<br><code>sudo $(brew --prefix e2fsprogs)/sbin/mkfs.ext4 /dev/disk3</code><br>回车，输入Mac电脑密码再回车，过程需要稍等片刻，等待完成即可拔掉 U盘，这时候 U盘格式已经为 ext4 了。</p>
</li>
</ol>
<p>注：如果是 Win 系统，请安装 MiniTool 软件来为 U盘格式化为 ext3或4，不需要输入任何代码，操作很简单。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.chaseshen.club/2018/10/03/微信小程序scroll-view横向滚动的坑/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chase Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chase's Club">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/03/微信小程序scroll-view横向滚动的坑/" itemprop="url">微信小程序scroll-view横向滚动的坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-03T23:23:02+00:00">
                2018-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>按照微信小程序文档写了个scroll-view设置横向滚动<code>scroll-x=&quot;true&quot;</code>，可是怎么都不动。。。<br>后来发现是要几个样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;scroll-view scroll-x=&quot;true&quot; style=&quot;background:black;height:110px; white-space: nowrap;&quot;&gt;</span><br><span class="line">  &lt;view style=&quot;background: red; width: 200px; height: 100px; display: inline-block;&quot;&gt;&lt;/view&gt;</span><br><span class="line">  &lt;view style=&quot;background: green; width: 200px; height: 100px; display: inline-block;&quot;&gt;&lt;/view&gt;</span><br><span class="line">  &lt;view style=&quot;background: blue; width: 200px; height: 100px; display: inline-block;&quot;&gt;&lt;/view&gt;</span><br><span class="line">  &lt;view style=&quot;background: yellow; width: 200px; height: 100px; display: inline-block;&quot;&gt;&lt;/view&gt;</span><br><span class="line">&lt;/scroll-view&gt;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>内部的view必须要设置宽高;</li>
<li>scroll-view容器要设置<code>white-space: nowrap;</code><br><code>white-space</code>属性设置如何处理元素内的空白：<ul>
<li>normal 默认。规定段落中的文本不进行换行,空白会被浏览器忽略。 </li>
<li>pre 空白会被浏览器保留。其行为方式类似 HTML 中的 pre 标签。 </li>
<li>nowrap 文本不会换行，文本会在在同一行上继续，直到遇到br 标签为止。 </li>
<li>pre-wrap 保留空白符序列，但是正常地进行换行。 </li>
<li>pre-line 合并空白符序列，但是保留换行符。 </li>
<li>inherit 规定应该从父元素继承 white-space 属性的值。</li>
</ul>
</li>
<li>内部的view要设置<code>display: inline-block;</code>。应用此特性的元素呈现为内联对象，周围元素保持在同一行。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.chaseshen.club/2018/09/26/PHP中的匿名函数和闭包/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chase Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chase's Club">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/26/PHP中的匿名函数和闭包/" itemprop="url">PHP中的匿名函数和闭包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-26T21:18:02+00:00">
                2018-09-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>匿名函数也叫闭包函数（closures），也就是没有定义名字的函数。<br>匿名函数的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$closureFunc = function () &#123;</span><br><span class="line">	......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为匿名函数没有名字，如果要使用它，需要将其赋值给一个变量，通过变量来调用。匿名函数也可以像普通函数一样声明参数，调用方法也相同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$func = function ($param) &#123;</span><br><span class="line">	echo $param;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$func(&apos;hello world&apos;);</span><br><span class="line"></span><br><span class="line">//输出：</span><br><span class="line">//hello world</span><br></pre></td></tr></table></figure></p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>将匿名函数放在普通函数中，这样就实现了一个简单的闭包。<br>参考下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">// 在函数里定义一个匿名函数，并且调用它</span><br><span class="line">function printStr () &#123;</span><br><span class="line">	$func = function ($str) &#123;</span><br><span class="line">		echo $str;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	$func(&apos;hello&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printStr();</span><br><span class="line">//输出：</span><br><span class="line">//hello</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">//在函数中把匿名函数返回，并且调用它</span><br><span class="line">function getPrintStrFunc () &#123;</span><br><span class="line">	$func = function ($str) &#123;</span><br><span class="line">		echo $str;</span><br><span class="line">	&#125;;</span><br><span class="line">	return $str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$printStrFunc = getPrintStrFunc();</span><br><span class="line">$printStrFunc(&apos;hello&apos;);</span><br><span class="line">//输出：</span><br><span class="line">//hello</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">//把匿名函数当做参数传递，并且调用它</span><br><span class="line">function callFunc($func) &#123;</span><br><span class="line">	$func(&apos;111&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$printFunc = function ($str) &#123;</span><br><span class="line">	echo $str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">callFunc($printFunc);</span><br><span class="line">//输出：</span><br><span class="line">//111</span><br><span class="line"></span><br><span class="line">//也可以直接将匿名函数进行传递。如果你了解js，这种写法可能会很熟悉</span><br><span class="line">callFunc( function( $str ) &#123;</span><br><span class="line">    echo $str;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure></p>
<h1 id="连接闭包和外界变量的关键字：USE"><a href="#连接闭包和外界变量的关键字：USE" class="headerlink" title="连接闭包和外界变量的关键字：USE"></a>连接闭包和外界变量的关键字：USE</h1><p>闭包可以保存所在代码块上下文的一些变量和值。PHP在默认情况下，匿名函数不能调用所在代码块的上下文变量，而需要通过使用use关键字。<br>换一个例子看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function getMoney() &#123;</span><br><span class="line">    $rmb = 1;</span><br><span class="line">    $dollar = 6;</span><br><span class="line">    $func = function() use ( $rmb ) &#123;</span><br><span class="line">        echo $rmb;</span><br><span class="line">        echo $dollar;</span><br><span class="line">    &#125;;</span><br><span class="line">    $func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getMoney();</span><br><span class="line"></span><br><span class="line">//输出：</span><br><span class="line">//1</span><br><span class="line">//报错，找不到dorllar变量</span><br></pre></td></tr></table></figure></p>
<p>可以看到，dollar没有在use关键字中声明，在这个匿名函数里也就不能获取到它，所以开发中要注意这个问题。</p>
<p>有人可能会想到，是否可以在匿名函数中改变上下文的变量，但我发现是不可以的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function getMoney() &#123;</span><br><span class="line">    $rmb = 1;</span><br><span class="line">    $func = function() use ( $rmb ) &#123;</span><br><span class="line">        echo $rmb;</span><br><span class="line">        //把$rmb的值加1</span><br><span class="line">        $rmb++;</span><br><span class="line">    &#125;;</span><br><span class="line">    $func();</span><br><span class="line">    echo $rmb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getMoney();</span><br><span class="line"></span><br><span class="line">//输出：</span><br><span class="line">//1</span><br><span class="line">//1</span><br></pre></td></tr></table></figure></p>
<p>啊，原来use所引用的也只不过是变量的一个副本而已。但是我想要完全引用变量，而不是复制。</p>
<p>要达到这种效果，其实在变量前加一个 &amp; 符号就可以了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function getMoney() &#123;</span><br><span class="line">    $rmb = 1;</span><br><span class="line">    $func = function() use ( &amp;$rmb ) &#123;</span><br><span class="line">        echo $rmb;</span><br><span class="line">        //把$rmb的值加1</span><br><span class="line">        $rmb++;</span><br><span class="line">    &#125;;</span><br><span class="line">    $func();</span><br><span class="line">    echo $rmb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getMoney();</span><br><span class="line"></span><br><span class="line">//输出：</span><br><span class="line">//1</span><br><span class="line">//2</span><br></pre></td></tr></table></figure></p>
<p>如果将匿名函数返回给外界，匿名函数会保存use所引用的变量，而外界则不能得到这些变量，这样形成‘闭包’这个概念可能会更清晰一些。</p>
<p>根据描述改变一下上面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function getMoneyFunc() &#123;</span><br><span class="line">    $rmb = 1;</span><br><span class="line">    $func = function() use ( &amp;$rmb ) &#123;</span><br><span class="line">        echo $rmb;</span><br><span class="line">        //把$rmb的值加1</span><br><span class="line">        $rmb++;</span><br><span class="line">    &#125;;</span><br><span class="line">    return $func;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$getMoney = getMoneyFunc();</span><br><span class="line">$getMoney();</span><br><span class="line">$getMoney();</span><br><span class="line">$getMoney();</span><br><span class="line"></span><br><span class="line">//输出：</span><br><span class="line">//1</span><br><span class="line">//2</span><br><span class="line">//3</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Chase Shen</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chase Shen</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
