<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="PHP中把以两个下划线开头的方法称为魔术方法（Magic Method），这些方法在PHP中有举足轻重的作用。魔术方法包括：  __construct()  类的构造函数 __destruct()  类的析构函数 __call()  在对象中调用一个不可访问的方法时调用 __callStatic()  在静态方式中调用一个不可访问的方法时调用 __get()  获得一个类的成员变量时调用 __se">
<meta property="og:type" content="article">
<meta property="og:title" content="[PHP基础回顾]PHP中十六个魔术方法详解">
<meta property="og:url" content="https://www.chaseshen.club/2018/11/20/PHP基础回顾-PHP中十六个魔术方法详解/index.html">
<meta property="og:site_name" content="Chase&#39;s Club">
<meta property="og:description" content="PHP中把以两个下划线开头的方法称为魔术方法（Magic Method），这些方法在PHP中有举足轻重的作用。魔术方法包括：  __construct()  类的构造函数 __destruct()  类的析构函数 __call()  在对象中调用一个不可访问的方法时调用 __callStatic()  在静态方式中调用一个不可访问的方法时调用 __get()  获得一个类的成员变量时调用 __se">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-03-18T11:12:28.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[PHP基础回顾]PHP中十六个魔术方法详解">
<meta name="twitter:description" content="PHP中把以两个下划线开头的方法称为魔术方法（Magic Method），这些方法在PHP中有举足轻重的作用。魔术方法包括：  __construct()  类的构造函数 __destruct()  类的析构函数 __call()  在对象中调用一个不可访问的方法时调用 __callStatic()  在静态方式中调用一个不可访问的方法时调用 __get()  获得一个类的成员变量时调用 __se">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.chaseshen.club/2018/11/20/PHP基础回顾-PHP中十六个魔术方法详解/">





  <title>[PHP基础回顾]PHP中十六个魔术方法详解 | Chase's Club</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chase's Club</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            Schedule
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.chaseshen.club/2018/11/20/PHP基础回顾-PHP中十六个魔术方法详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chase Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chase's Club">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">[PHP基础回顾]PHP中十六个魔术方法详解</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-20T17:54:16+08:00">
                2018-11-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>PHP中把以两个下划线开头的方法称为魔术方法（Magic Method），这些方法在PHP中有举足轻重的作用。<br>魔术方法包括：</p>
<ul>
<li>__construct()  类的构造函数</li>
<li>__destruct()  类的析构函数</li>
<li>__call()  在对象中调用一个不可访问的方法时调用</li>
<li>__callStatic()  在静态方式中调用一个不可访问的方法时调用</li>
<li>__get()  获得一个类的成员变量时调用</li>
<li>__set()  设置一个类的成员变量时调用</li>
<li>__isset()  当对不可访问的属性调用isset()或empty()时调用</li>
<li>__unset()  当对不可访问的属性调用unset()时调用</li>
<li>__sleep()  执行serialize()时，先会调用这个方法</li>
<li>__wakeup()  执行unserialize()时，先会调用这个方法</li>
<li>__toString()  类被当做字符串时的回应方法</li>
<li>__invoke()  调用函数的方式调用一个对象时的回应方法</li>
<li>__set_state()  调用var_export()导出类时，此静态方法会被调用</li>
<li>__clone()  当对象复制完成时调用</li>
<li>__autoload()  尝试加载未定义的类</li>
<li>__debugInfo()  打印所需调试信息</li>
</ul>
<h1 id="construct"><a href="#construct" class="headerlink" title="__construct()"></a>__construct()</h1><p>类的构造函数，是对象创建完成后第一个被对象调用的方法。在每个类中都有一个构造方法，如果没有显示地声明它，那么类中都会默认存在一个没有参数且内容为空的构造方法。</p>
<ul>
<li><p>构造方法的作用<br>通常构造方法被用来执行一些有用的初始化任务，如对成员属性在创建对象时赋予初始值。</p>
</li>
<li><p>构造方法的在类中的声明格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function __constrct([参数列表])&#123;</span><br><span class="line"></span><br><span class="line">    方法体 //通常用来对成员属性进行初始化赋值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在类中声明构造方法需要注意的事项</p>
</li>
</ul>
<ol>
<li>在同一个类中只能声明一个构造方法，原因是，PHP不支持构造函数重载。</li>
<li>构造方法名称是以两个下画线开始的__construct()</li>
</ol>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    class Person</span><br><span class="line">    &#123;                                                                      </span><br><span class="line">            public $name;        </span><br><span class="line">            public $age;        </span><br><span class="line">            public $sex;        </span><br><span class="line">                                                                 </span><br><span class="line">        /**</span><br><span class="line">         * 显示声明一个构造方法且带参数</span><br><span class="line">         */                                                                                       </span><br><span class="line">        public function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=22)</span><br><span class="line">        &#123;      </span><br><span class="line">            $this-&gt;name = $name;</span><br><span class="line">            $this-&gt;sex = $sex;</span><br><span class="line">            $this-&gt;age = $age;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        /**</span><br><span class="line">         * say 方法</span><br><span class="line">         */</span><br><span class="line">        public function say()</span><br><span class="line">        &#123; </span><br><span class="line">            echo &quot;我叫：&quot; . $this-&gt;name . &quot;，性别：&quot; . $this-&gt;sex . &quot;，年龄：&quot; . $this-&gt;age;</span><br><span class="line">        &#125;   </span><br><span class="line">                                                                                           </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>创建对象$Person1且不带任参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$Person1 = new Person();</span><br><span class="line">echo $Person1-&gt;say(); //输出:我叫：，性别：男，年龄：27</span><br></pre></td></tr></table></figure></p>
<p>创建对象$Person2且带参数“小明”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$Person2 = new Person(&quot;小明&quot;);</span><br><span class="line">echo $Person2-&gt;say(); //输出：我叫：小明，性别：男，年龄：22</span><br></pre></td></tr></table></figure></p>
<p>创建对象$Person3且带三个参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$Person3 = new Person(&quot;李四&quot;,&quot;男&quot;,25);</span><br><span class="line">echo $Person3-&gt;say(); //输出：我叫：李四，性别：男，年龄：25</span><br></pre></td></tr></table></figure></p>
<h1 id="destruct"><a href="#destruct" class="headerlink" title="__destruct()"></a>__destruct()</h1><p>类的析构函数，与构造方法对应的就是析构方法。<br>析构方法允许在销毁一个类之前执行的一些操作或完成一些功能，比如说关闭文件、释放结果集等。</p>
<p>析构方法是PHP5才引进的新内容。</p>
<p>析造方法的声明格式与构造方法 <strong>construct() 比较类似，也是以两个下划线开始的方法 </strong>destruct() ，这种析构方法名称也是固定的。</p>
<ul>
<li>析构方法的声明格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function __destruct()</span><br><span class="line">&#123;</span><br><span class="line"> //方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：析构函数不能带有任何参数。</p>
<ul>
<li>析构方法的作用<br>一般来说，析构方法在PHP中并不是很常用，它属类中可选择的一部分，通常用来完成一些在对象销毁前的清理任务。</li>
</ul>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person&#123;     </span><br><span class="line">                                                        </span><br><span class="line">    public $name;         </span><br><span class="line">    public $age;         </span><br><span class="line">    public $sex;         </span><br><span class="line">                                                                    </span><br><span class="line">    public function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=22)</span><br><span class="line">    &#123;   </span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;sex  = $sex;</span><br><span class="line">        $this-&gt;age  = $age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * say 说话方法</span><br><span class="line">     */</span><br><span class="line">    public function say()</span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;我叫：&quot;.$this-&gt;name.&quot;，性别：&quot;.$this-&gt;sex.&quot;，年龄：&quot;.$this-&gt;age;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 声明一个析构方法</span><br><span class="line">     */</span><br><span class="line">    public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">            echo &quot;我觉得我还可以再抢救一下，我的名字叫&quot;.$this-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$Person = new Person(&quot;小明&quot;);</span><br><span class="line">unset($Person); //销毁上面创建的对象$Person</span><br></pre></td></tr></table></figure></p>
<p>上面的程序运行时输出：<br><code>我觉得我还可以再抢救一下，我的名字叫小明</code></p>
<h1 id="call"><a href="#call" class="headerlink" title="__call()"></a>__call()</h1><p>在对象中调用一个不可访问方法时调用，该方法有两个参数，第一个参数<code>$function_name</code>会自动接收不存在的方法名，第二个<code>$arguments</code>则以数组的方式接收不存在方法的多个参数。</p>
<ul>
<li><p>__call() 方法的格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function __call(string $function_name, array $arguments)</span><br><span class="line">&#123;</span><br><span class="line">    // 方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>call() 方法的作用<br>为了避免当调用的方法不存在时产生错误，而意外的导致程序中止，可以使用 </strong>call() 方法来避免。</p>
</li>
</ul>
<p>该方法在调用的方法不存在时会自动调用，程序仍会继续执行下去。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;                             </span><br><span class="line">    function say()</span><br><span class="line">    &#123;  </span><br><span class="line">                              </span><br><span class="line">           echo &quot;Hello, world!&lt;br&gt;&quot;; </span><br><span class="line">    &#125;      </span><br><span class="line">        </span><br><span class="line">    /**</span><br><span class="line">     * 声明此方法用来处理调用对象中不存在的方法</span><br><span class="line">     */</span><br><span class="line">    function __call($funName, $arguments)</span><br><span class="line">    &#123; </span><br><span class="line">          echo &quot;你所调用的函数：&quot; . $funName . &quot;(参数：&quot; ;  // 输出调用不存在的方法名</span><br><span class="line">          print_r($arguments); // 输出调用不存在的方法时的参数列表</span><br><span class="line">          echo &quot;)不存在！&lt;br&gt;\n&quot;; // 结束换行                      </span><br><span class="line">    &#125;                                          </span><br><span class="line">&#125;</span><br><span class="line">$Person = new Person();            </span><br><span class="line">$Person-&gt;run(&quot;teacher&quot;); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法</span><br><span class="line">$Person-&gt;eat(&quot;小明&quot;, &quot;苹果&quot;);             </span><br><span class="line">$Person-&gt;say();</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">你所调用的函数：run(参数：Array ( [0] =&gt; teacher ) )不存在！</span><br><span class="line"></span><br><span class="line">你所调用的函数：eat(参数：Array ( [0] =&gt; 小明 [1] =&gt; 苹果 ) )不存在！</span><br><span class="line"></span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure></p>
<h1 id="callStatic"><a href="#callStatic" class="headerlink" title="__callStatic()"></a>__callStatic()</h1><p>用静态方式中调用一个不可访问方法时调用，此方法与上面所说的<code>__call()</code>功能除了<code>__callStatic()</code>是为静态方法准备的之外，其它都是一样的。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    function say()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        echo &quot;Hello, world!&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 声明此方法用来处理调用对象中不存在的方法</span><br><span class="line">     */</span><br><span class="line">    public static function __callStatic($funName, $arguments)</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;你所调用的静态方法：&quot; . $funName . &quot;(参数：&quot; ;  // 输出调用不存在的方法名</span><br><span class="line">        print_r($arguments); // 输出调用不存在的方法时的参数列表</span><br><span class="line">        echo &quot;)不存在！&lt;br&gt;\n&quot;; // 结束换行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$Person = new Person();</span><br><span class="line">$Person::run(&quot;teacher&quot;); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法</span><br><span class="line">$Person::eat(&quot;小明&quot;, &quot;苹果&quot;);</span><br><span class="line">$Person-&gt;say();</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你所调用的静态方法：run(参数：Array ( [0] =&gt; teacher ) )不存在！</span><br><span class="line">你所调用的静态方法：eat(参数：Array ( [0] =&gt; 小明 [1] =&gt; 苹果 ) )不存在！</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure></p>
<h1 id="get"><a href="#get" class="headerlink" title="__get()"></a>__get()</h1><p>获得一个类的成员变量时调用。在 php 面向对象编程中，类的成员属性被设定为<code>private</code>后，如果我们试图在外面调用它则会出现“不能访问某个私有属性”的错误。那么为了解决这个问题，我们可以使用魔术方法<code>__get()</code>。</p>
<ul>
<li>魔术方法__get()的作用<br>在程序运行过程中，通过它可以在对象的外部获取私有成员属性的值。</li>
</ul>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    private $name;</span><br><span class="line">    private $age;</span><br><span class="line"></span><br><span class="line">    function __construct($name=&quot;&quot;, $age=1)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age = $age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在类中添加__get()方法，在直接获取属性值时自动调用一次，以属性名作为参数传入并处理</span><br><span class="line">     * @param $propertyName</span><br><span class="line">     *</span><br><span class="line">     * @return int</span><br><span class="line">     */</span><br><span class="line">    public function __get($propertyName)</span><br><span class="line">    &#123;   </span><br><span class="line">        if ($propertyName == &quot;age&quot;) &#123;</span><br><span class="line">            if ($this-&gt;age &gt; 30) &#123;</span><br><span class="line">                return $this-&gt;age - 10;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return $this-&gt;$propertyName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return $this-&gt;$propertyName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$Person = new Person(&quot;小明&quot;, 60);   // 通过Person类实例化的对象，并通过构造方法为属性赋初值</span><br><span class="line">echo &quot;姓名：&quot; . $Person-&gt;name . &quot;&lt;br&gt;&quot;;   // 直接访问私有属性name，自动调用了__get()方法可以间接获取</span><br><span class="line">echo &quot;年龄：&quot; . $Person-&gt;age . &quot;&lt;br&gt;&quot;;    // 自动调用了__get()方法，根据对象本身的情况会返回不同的值</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">姓名：小明</span><br><span class="line">年龄：50</span><br></pre></td></tr></table></figure></p>
<h1 id="set"><a href="#set" class="headerlink" title="__set()"></a>__set()</h1><p>设置一个类的成员变量时调用。设置私有属性， 给一个未定义的属性赋值时，此方法会被触发，传递的参数是被设置的<code>属性名</code>和<code>值</code>。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    private $name;</span><br><span class="line">    private $age;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&quot;&quot;,  $age=25)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age  = $age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 声明魔术方法需要两个参数，真接为私有属性赋值时自动调用，并可以屏蔽一些非法赋值</span><br><span class="line">     * @param $property</span><br><span class="line">     * @param $value</span><br><span class="line">     */</span><br><span class="line">    public function __set($property, $value) &#123;</span><br><span class="line">        if ($property==&quot;age&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            if ($value &gt; 150 || $value &lt; 0) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        $this-&gt;$property = $value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在类中声明说话的方法，将所有的私有属性说出</span><br><span class="line">     */</span><br><span class="line">    public function say()&#123;</span><br><span class="line">        echo &quot;我叫&quot;.$this-&gt;name.&quot;，今年&quot;.$this-&gt;age.&quot;岁了&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$Person=new Person(&quot;小明&quot;, 25); //注意，初始值将被下面所改变</span><br><span class="line">//自动调用了__set()函数，将属性名name传给第一个参数，将属性值”小红”传给第二个参数</span><br><span class="line">$Person-&gt;name = &quot;小红&quot;;     //赋值成功。如果没有__set()，则出错。</span><br><span class="line">//自动调用了__set()函数，将属性名age传给第一个参数，将属性值16传给第二个参数</span><br><span class="line">$Person-&gt;age = 16; //赋值成功</span><br><span class="line">$Person-&gt;age = 160; //160是一个非法值，赋值失效</span><br><span class="line">$Person-&gt;say();  //输出：我叫小红，今年16岁了</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我叫小红，今年16岁了</span><br></pre></td></tr></table></figure></p>
<h1 id="isset"><a href="#isset" class="headerlink" title="__isset()"></a>__isset()</h1><p>当对不可访问属性调用<code>isset()</code>或<code>empty()</code>时调用。</p>
<p>在看这个方法之前我们看一下<code>isset()</code>函数的应用，<code>isset()</code>是测定变量是否设定用的函数，传入一个变量作为参数，如果传入的变量存在则传回<code>true</code>，否则传回<code>false</code>。<br>那么如果在一个对象外面使用<code>isset()</code>这个函数去测定对象里面的成员是否被设定可不可以用它呢？</p>
<p>分两种情况，如果对象里面成员是公有的，我们就可以使用这个函数来测定成员属性，如果是私有的成员属性，这个函数就不起作用了，原因就是因为私有的被封装了，在外部不可见。那么我们就不可以在对象的外部使用<code>isset()</code>函数来测定私有成员属性是否被设定了呢？当然是可以的，但不是一成不变。你只要在类里面加上一个<code>__isset()</code>方法就可以了，当在类外部使用<code>isset()</code>函数来测定对象里面的私有成员是否被设定时，就会自动调用类里面的<code>__isset()</code>方法了帮我们完成这样的操作。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public $sex;</span><br><span class="line">    private $name;</span><br><span class="line">    private $age;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age  = $age;</span><br><span class="line">        $this-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param $content</span><br><span class="line">     *</span><br><span class="line">     * @return bool</span><br><span class="line">     */</span><br><span class="line">    public function __isset($content) &#123;</span><br><span class="line">        echo &quot;当在类外部使用isset()函数测定私有成员&#123;$content&#125;时，自动调用&lt;br&gt;&quot;;</span><br><span class="line">        echo  isset($this-&gt;$content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = new Person(&quot;小明&quot;, 25); // 初始赋值</span><br><span class="line">echo isset($person-&gt;sex),&quot;&lt;br&gt;&quot;;</span><br><span class="line">echo isset($person-&gt;name),&quot;&lt;br&gt;&quot;;</span><br><span class="line">echo isset($person-&gt;age),&quot;&lt;br&gt;&quot;;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 // public 可以 isset()</span><br><span class="line">当在类外部使用isset()函数测定私有成员name时，自动调用 // __isset() 内 第一个echo</span><br><span class="line">1 // __isset() 内第二个echo</span><br><span class="line">当在类外部使用isset()函数测定私有成员age时，自动调用 // __isset() 内 第一个echo</span><br><span class="line">1 // __isset() 内第二个echo</span><br></pre></td></tr></table></figure></p>
<h1 id="unset"><a href="#unset" class="headerlink" title="__unset()"></a>__unset()</h1><p>当对不可访问属性调用<code>unset()</code>时被调用。</p>
<p>看这个方法之前呢，我们也先来看一下<code>unset()</code>函数，<code>unset()</code>这个函数的作用是删除指定的变量且传回<code>true</code>，参数为要删除的变量。</p>
<p>那么如果在一个对象外部去删除对象内部的成员属性用<code>unset()</code>函数可以吗？</p>
<p>这里自然也是分两种情况：</p>
<ol>
<li><p>如果一个对象里面的成员属性是公有的，就可以使用这个函数在对象外面删除对象的公有属性。</p>
</li>
<li><p>如果对象的成员属性是私有的，我使用这个函数就没有权限去删除。</p>
</li>
</ol>
<p>虽然有以上两种情况，但我想说的是同样如果你在一个对象里面加上<code>__unset()</code>这个方法，就可以在对象的外部去删除对象的私有成员属性了。在对象里面加上了<code>__unset()</code>这个方法之后，在对象外部使用<code>unset()</code>函数删除对象内部的私有成员属性时，对象会自动调用<code>__unset()</code>函数来帮我们删除对象内部的私有成员属性。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public $sex;</span><br><span class="line">    private $name;</span><br><span class="line">    private $age;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age  = $age;</span><br><span class="line">        $this-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param $content</span><br><span class="line">     *</span><br><span class="line">     * @return bool</span><br><span class="line">     */</span><br><span class="line">    public function __unset($content) &#123;</span><br><span class="line">        echo &quot;当在类外部使用unset()函数来删除私有成员时自动调用的&lt;br&gt;&quot;;</span><br><span class="line">        echo  isset($this-&gt;$content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = new Person(&quot;小明&quot;, 25); // 初始赋值</span><br><span class="line">unset($person-&gt;sex);</span><br><span class="line">unset($person-&gt;name);</span><br><span class="line">unset($person-&gt;age);</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当在类外部使用unset()函数来删除私有成员时自动调用的</span><br><span class="line">1当在类外部使用unset()函数来删除私有成员时自动调用的</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<h1 id="sleep"><a href="#sleep" class="headerlink" title="__sleep()"></a>__sleep()</h1><p>执行<code>serialize()</code>时，先会调用这个函数。<code>serialize()</code>函数会检查类中是否存在一个魔术方法<code>__sleep()</code>。如果存在，则该方法会优先被调用，然后才执行序列化操作。</p>
<p>此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。</p>
<p>如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。</p>
<p>注意：<br><code>__sleep()</code>不能返回父类的私有成员的名字。这样做会产生一个 E_NOTICE 级别的错误。可以用 Serializable 接口来替代。</p>
<p>作用：<br><code>__sleep()</code>方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public $sex;</span><br><span class="line">    public $name;</span><br><span class="line">    public $age;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age  = $age;</span><br><span class="line">        $this-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @return array</span><br><span class="line">     */</span><br><span class="line">    public function __sleep() &#123;</span><br><span class="line">        echo &quot;当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;&quot;;</span><br><span class="line">        $this-&gt;name = base64_encode($this-&gt;name);</span><br><span class="line">        return array(&apos;name&apos;, &apos;age&apos;); // 这里必须返回一个数值，里边的元素表示返回的属性名称</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</span><br><span class="line">echo serialize($person);</span><br><span class="line">echo &apos;&lt;br/&gt;&apos;;</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当在类外部使用serialize()时会调用这里的__sleep()方法</span><br><span class="line">O:6:&quot;Person&quot;:2:&#123;s:4:&quot;name&quot;;s:8:&quot;5bCP5piO&quot;;s:3:&quot;age&quot;;i:25;&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="wakeup"><a href="#wakeup" class="headerlink" title="__wakeup()"></a>__wakeup()</h1><p>执行unserialize()时，先会调用这个函数。<br>与之相反，<code>unserialize()</code>会检查是否存在一个<code>__wakeup()</code>方法。如果存在，则会先调用<code>__wakeup</code>方法，预先准备对象需要的资源。</p>
<p>作用：<br><code>__wakeup()</code>经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public $sex;</span><br><span class="line">    public $name;</span><br><span class="line">    public $age;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age  = $age;</span><br><span class="line">        $this-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @return array</span><br><span class="line">     */</span><br><span class="line">    public function __sleep() &#123;</span><br><span class="line">        echo &quot;当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;&quot;;</span><br><span class="line">        $this-&gt;name = base64_encode($this-&gt;name);</span><br><span class="line">        return array(&apos;name&apos;, &apos;age&apos;); // 这里必须返回一个数值，里边的元素表示返回的属性名称</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * __wakeup</span><br><span class="line">     */</span><br><span class="line">    public function __wakeup() &#123;</span><br><span class="line">        echo &quot;当在类外部使用unserialize()时会调用这里的__wakeup()方法&lt;br&gt;&quot;;</span><br><span class="line">        $this-&gt;name = 2;</span><br><span class="line">        $this-&gt;sex = &apos;男&apos;;</span><br><span class="line">        // 这里不需要返回数组</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</span><br><span class="line">var_dump(serialize($person));</span><br><span class="line">var_dump(unserialize(serialize($person)));</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当在类外部使用serialize()时会调用这里的__sleep()方法</span><br><span class="line">string(58) &quot;O:6:&quot;Person&quot;:2:&#123;s:4:&quot;name&quot;;s:8:&quot;5bCP5piO&quot;;s:3:&quot;age&quot;;i:25;&#125;&quot; 当在类外部使用serialize()时会调用这里的__sleep()方法</span><br><span class="line">当在类外部使用unserialize()时会调用这里的__wakeup()方法</span><br><span class="line">object(Person)#2 (3) &#123; [&quot;sex&quot;]=&gt; string(3) &quot;男&quot; [&quot;name&quot;]=&gt; int(2) [&quot;age&quot;]=&gt; int(25) &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString()"></a>__toString()</h1><p>类被当成字符串时的回应方法。<br>作用：<br><code>__toString()</code>方法用于一个类被当成字符串时应怎样回应。例如 <code>echo $obj;</code> 应该显示些什么。</p>
<p>注意：<br>此方法必须返回一个字符串，否则将发出一条 <code>E_RECOVERABLE_ERROR</code> 级别的致命错误。</p>
<p>警告：<br>不能在<code>__toString()</code>方法中抛出异常。这么做会导致致命错误。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public $sex;</span><br><span class="line">    public $name;</span><br><span class="line">    public $age;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age  = $age;</span><br><span class="line">        $this-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __toString()</span><br><span class="line">    &#123;</span><br><span class="line">        return  &apos;go go go&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</span><br><span class="line">echo $person;</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go go go</span><br></pre></td></tr></table></figure></p>
<p>那么如果类中没有 __toString() 这个魔术方法运行会发生什么呢？让我们来测试下：</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public $sex;</span><br><span class="line">    public $name;</span><br><span class="line">    public $age;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age  = $age;</span><br><span class="line">        $this-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</span><br><span class="line">echo $person;</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Catchable fatal error: Object of class Person could not be converted to string in D:\phpStudy\WWW\test\index.php on line 18</span><br></pre></td></tr></table></figure></p>
<p>页面报了一个致命错误，这是语法所不允许的。</p>
<h1 id="invoke"><a href="#invoke" class="headerlink" title="__invoke()"></a>__invoke()</h1><p>调用函数的方式调用一个对象时的回应方法。</p>
<p>作用：<br>当尝试以调用函数的方式调用一个对象时，<code>__invoke()</code>方法会被自动调用。</p>
<p>注意：<br>本特性只在 PHP 5.3.0 及以上版本有效。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public $sex;</span><br><span class="line">    public $name;</span><br><span class="line">    public $age;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age  = $age;</span><br><span class="line">        $this-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __invoke() &#123;</span><br><span class="line">        echo &apos;这可是一个对象哦&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</span><br><span class="line">$person();</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这可是一个对象哦</span><br></pre></td></tr></table></figure></p>
<p>如果执意要将对象当函数方法使用，那么会得到下面结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fatal error: Function name must be a string in D:\phpStudy\WWW\test\index.php on line 18</span><br></pre></td></tr></table></figure></p>
<h1 id="set-state"><a href="#set-state" class="headerlink" title="__set_state()"></a>__set_state()</h1><p>调用var_export()导出类时，此静态方法会被调用。</p>
<p>作用：<br>自 PHP 5.1.0 起，当调用<code>var_export()</code>导出类时，此静态方法会被自动调用。</p>
<p>参数：<br>本方法的唯一参数是一个数组，其中包含按<code>array(&#39;property&#39; =&gt; value, ...)</code>格式排列的类属性。</p>
<p>下面在没有加 __set_state() 情况按下，代码及运行结果如何：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public $sex;</span><br><span class="line">    public $name;</span><br><span class="line">    public $age;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age  = $age;</span><br><span class="line">        $this-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</span><br><span class="line">var_export($person);</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person::__set_state(array( &apos;sex&apos; =&gt; &apos;男&apos;, &apos;name&apos; =&gt; &apos;小明&apos;, &apos;age&apos; =&gt; 25, ))</span><br></pre></td></tr></table></figure></p>
<p>对象中的属性都打印出来了。</p>
<p>加了<code>__set_state()</code>之后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public $sex;</span><br><span class="line">    public $name;</span><br><span class="line">    public $age;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age  = $age;</span><br><span class="line">        $this-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static function __set_state($an_array)</span><br><span class="line">    &#123;</span><br><span class="line">        $a = new Person();</span><br><span class="line">        $a-&gt;name = $an_array[&apos;name&apos;];</span><br><span class="line">        return $a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</span><br><span class="line">$person-&gt;name = &apos;小红&apos;;</span><br><span class="line">var_export($person);</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person::__set_state(array( &apos;sex&apos; =&gt; &apos;男&apos;, &apos;name&apos; =&gt; &apos;小红&apos;, &apos;age&apos; =&gt; 25, ))</span><br></pre></td></tr></table></figure></p>
<h1 id="clone"><a href="#clone" class="headerlink" title="__clone()"></a>__clone()</h1><p>当对象复制完成时调用。<br>在多数情况下，我们并不需要完全复制一个对象来获得其中属性。但有一个情况下确实需要：如果你有一个 GTK 窗口对象，该对象持有窗口相关的资源。你可能会想复制一个新的窗口，保持所有属性与原来的窗口相同，但必须是一个新的对象（因为如果不是新的对象，那么一个窗口中的改变就会影响到另一个窗口）。还有一种情况：如果对象 A 中保存着对象 B 的引用，当你复制对象 A 时，你想其中使用的对象不再是对象 B 而是 B 的一个副本，那么你必须得到对象 A 的一个副本。</p>
<p>作用：<br>对象复制可以通过<code>clone</code>关键字来完成（如果可能，这将调用对象的<code>__clone()</code>方法）。对象中的<code>__clone()</code>方法不能被直接调用。</p>
<p>语法：<br><code>$copy_of_object = clone $object;</code></p>
<p>注意：<br>当对象被复制后，PHP 5 会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性 仍然会是一个指向原来的变量的引用。</p>
<p>当复制完成时，如果定义了<code>__clone()</code>方法，则新创建的对象（复制生成的对象）中的<code>__clone()</code>方法会被调用，可用于修改属性的值（如果有必要的话）。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public $sex;</span><br><span class="line">    public $name;</span><br><span class="line">    public $age;</span><br><span class="line"></span><br><span class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age  = $age;</span><br><span class="line">        $this-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __clone()</span><br><span class="line">    &#123;</span><br><span class="line">        echo __METHOD__.&quot;你正在克隆对象&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</span><br><span class="line">$person2 = clone $person;</span><br><span class="line"></span><br><span class="line">var_dump(&apos;persion1:&apos;);</span><br><span class="line">var_dump($person);</span><br><span class="line">echo &apos;&lt;br&gt;&apos;;</span><br><span class="line">var_dump(&apos;persion2:&apos;);</span><br><span class="line">var_dump($person2);</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person::__clone你正在克隆对象</span><br><span class="line">string(9) &quot;persion1:&quot; object(Person)#1 (3) &#123; [&quot;sex&quot;]=&gt; string(3) &quot;男&quot; [&quot;name&quot;]=&gt; string(6) &quot;小明&quot; [&quot;age&quot;]=&gt; int(25) &#125; </span><br><span class="line">string(9) &quot;persion2:&quot; object(Person)#2 (3) &#123; [&quot;sex&quot;]=&gt; string(3) &quot;男&quot; [&quot;name&quot;]=&gt; string(6) &quot;小明&quot; [&quot;age&quot;]=&gt; int(25) &#125;</span><br></pre></td></tr></table></figure></p>
<p>克隆成功。</p>
<h1 id="autoload"><a href="#autoload" class="headerlink" title="__autoload()"></a>__autoload()</h1><p>尝试加载未定义的类。</p>
<p>作用：<br>你可以通过定义这个函数来启用类的自动加载。</p>
<p>在魔术函数<code>__autoload()</code>方法出现以前，如果你要在一个程序文件中实例化100个对象，那么你必须用<code>include</code>或者<code>require</code>包含进来100个类文件，或者你把这100个类定义在同一个类文件中 —— 相信这个文件一定会非常大，然后你就痛苦了。</p>
<p>但是有了<code>__autoload()</code>方法，以后就不必为此大伤脑筋了，这个类会在你实例化对象之前自动加载制定的文件。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 文件non_autoload.php </span><br><span class="line"> */ </span><br><span class="line">   </span><br><span class="line">require_once(&apos;project/class/A.php&apos;);  </span><br><span class="line">require_once(&apos;project/class/B.php&apos;);  </span><br><span class="line">require_once(&apos;project/class/C.php&apos;);  </span><br><span class="line">   </span><br><span class="line">if (条件A) &#123;  </span><br><span class="line">    $a = new A();  </span><br><span class="line">    $b = new B();  </span><br><span class="line">    $c = new C();  </span><br><span class="line">    // … 业务逻辑  </span><br><span class="line">&#125; else if (条件B) &#123;  </span><br><span class="line">    $a = newA();  </span><br><span class="line">    $b = new B();  </span><br><span class="line">    // … 业务逻辑  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到了吗？不用100个，只是3个看起来就有点烦了。而且这样就会有一个问题：如果脚本执行“条件B”这个分支时，C.php这个文件其实没有必要包含。因为，任何一个被包含的文件，无论是否使用，均会被php引擎编译。如果不使用，却被编译，这样可以被视作一种资源浪费。更进一步，如果C.php包含了D.php，D.php包含了E.php。并且大部分情况都执行“条件B”分支，那么就会浪费一部分资源去编译C.php,D.php,E.php三个“无用”的文件。</p>
<p>那么如果使用<code>__autoload()</code>方式呢？</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 文件autoload_demo.php </span><br><span class="line"> */ </span><br><span class="line">function  __autoload($className) &#123;  </span><br><span class="line">    $filePath = “project/class/&#123;$className&#125;.php”;  </span><br><span class="line">    if (is_readable($filePath)) &#123;  </span><br><span class="line">        require($filePath);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line">if (条件A) &#123;  </span><br><span class="line">    $a = new A();  </span><br><span class="line">    $b = new B();  </span><br><span class="line">    $c = new C();  </span><br><span class="line">    // … 业务逻辑  </span><br><span class="line">&#125; else if (条件B) &#123;  </span><br><span class="line">    $a = newA();  </span><br><span class="line">    $b = new B();  </span><br><span class="line">    // … 业务逻辑  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ok,不论效率怎么用，最起码界面看起来舒服多了，没有太多冗余的代。</p>
<p>当php引擎第一次使用类A，但是找不到时，会自动调用<code>__autoload()</code>方法，并将类名“A”作为参数传入。所以，我们在<code>__autoload()</code>中需要的做的就是根据类名，找到相应的文件，并包含进来，如果我们的方法也找不到，那么php引擎就会报错了。</p>
<p>注意：<br>这里可以只用<code>require</code>，因为一旦包含进来后，php引擎再遇到类A时，将不会调用<code>__autoload()</code>，而是直接使用内存中的类A，不会导致多次包含。</p>
<p>扩展：<br>其实php发展到今天，已经有将 <code>spl_autoload_register</code> — 注册给定的函数作为<code>__autoload()</code>的实现了，但是这个不在啊本文讲解之内，有兴趣可以自行看手册。</p>
<h1 id="debugInfo"><a href="#debugInfo" class="headerlink" title="__debugInfo()"></a>__debugInfo()</h1><p>打印所需调试信息。</p>
<p>注意：<br>该方法在PHP 5.6.0及其以上版本才可以用，如果你发现使用无效或者报错，请查看啊你的版本。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class C &#123;</span><br><span class="line">    private $prop;</span><br><span class="line"></span><br><span class="line">    public function __construct($val) &#123;</span><br><span class="line">        $this-&gt;prop = $val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @return array</span><br><span class="line">     */</span><br><span class="line">    public function __debugInfo() &#123;</span><br><span class="line">        return [</span><br><span class="line">            &apos;propSquared&apos; =&gt; $this-&gt;prop ** 2,</span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump(new C(42));</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object(C)#1 (1) &#123; [&quot;propSquared&quot;]=&gt; int(1764) &#125;</span><br></pre></td></tr></table></figure></p>
<p>再次注意：<br>这里的 <code>**</code> 是乘方的意思，也是在PHP5.6.0及其以上才可以使用，详情请查看PHP手册</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/20/PHP基础回顾-可变变量和引用操作符/" rel="next" title="[PHP基础回顾]可变变量和引用操作符">
                <i class="fa fa-chevron-left"></i> [PHP基础回顾]可变变量和引用操作符
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/09/Laradock中MySQL连接的坑/" rel="prev" title="Laradock中MySQL连接的坑">
                Laradock中MySQL连接的坑 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Chase Shen</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#construct"><span class="nav-number">1.</span> <span class="nav-text">__construct()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#destruct"><span class="nav-number">2.</span> <span class="nav-text">__destruct()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#call"><span class="nav-number">3.</span> <span class="nav-text">__call()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#callStatic"><span class="nav-number">4.</span> <span class="nav-text">__callStatic()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#get"><span class="nav-number">5.</span> <span class="nav-text">__get()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#set"><span class="nav-number">6.</span> <span class="nav-text">__set()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#isset"><span class="nav-number">7.</span> <span class="nav-text">__isset()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#unset"><span class="nav-number">8.</span> <span class="nav-text">__unset()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sleep"><span class="nav-number">9.</span> <span class="nav-text">__sleep()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#wakeup"><span class="nav-number">10.</span> <span class="nav-text">__wakeup()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#toString-NaN"><span class="nav-number">11.</span> <span class="nav-text">__toString()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#invoke"><span class="nav-number">12.</span> <span class="nav-text">__invoke()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#set-state"><span class="nav-number">13.</span> <span class="nav-text">__set_state()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#clone"><span class="nav-number">14.</span> <span class="nav-text">__clone()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#autoload"><span class="nav-number">15.</span> <span class="nav-text">__autoload()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#debugInfo"><span class="nav-number">16.</span> <span class="nav-text">__debugInfo()</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chase Shen</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
